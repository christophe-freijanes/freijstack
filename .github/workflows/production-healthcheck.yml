name: ðŸ¥ Production Health Check

on:
  schedule:
    - cron: "*/30 * * * *"
  workflow_dispatch:
    inputs:
      auto_heal:
        description: "ðŸ”§ RedÃ©marrer automatiquement si problÃ¨me dÃ©tectÃ©"
        required: false
        default: true
        type: boolean
  push:
    branches: [master]

concurrency:
  group: production-healthcheck
  cancel-in-progress: true

permissions:
  contents: read
  actions: read

jobs:
  health-check:
    name: ðŸ¥ Check Production Health
    runs-on: ubuntu-latest
    timeout-minutes: 6

    outputs:
      backend_status: ${{ steps.backend.outputs.status }}
      db_status: ${{ steps.database.outputs.status }}

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ” Secret scanning (Gitleaks CLI)
        id: gitleaks
        run: |
          set -euo pipefail
      
          echo "â¬‡ï¸ Installing gitleaks (pinned version)..."
          GITLEAKS_VERSION="8.21.2"
          curl -sSL "https://github.com/gitleaks/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz" \
            | tar -xz gitleaks
          sudo mv gitleaks /usr/local/bin/gitleaks
      
          echo "ðŸ”Ž Running gitleaks with ignore file (redacted)..."
          gitleaks detect \
            --source . \
            --config .gitleaks.toml \
            --redact \
            --report-format json \
            --report-path gitleaks-report.json \
            --verbose || true
          
          test -f gitleaks-report.json || echo "[]" > gitleaks-report.json

          echo ""
          echo "ðŸ“„ Findings (safe metadata):"
          if [ -s gitleaks-report.json ]; then
            jq -r '.[] | "\(.RuleID) file=\(.File) line=\(.StartLine) commit=\(.Commit|tostring|.[0:8])"' gitleaks-report.json | nl -w2 -s'. '
            leaks_count="$(jq 'length' gitleaks-report.json)"
          else
            echo "âœ… No findings report (empty file)."
            leaks_count="0"
          fi
      
          echo "leaks_count=${leaks_count}" >> "$GITHUB_OUTPUT"
          echo "ðŸ”¢ leaks_count=${leaks_count}"

      - name: ðŸ“Ž Upload gitleaks report (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: gitleaks-report.json
          retention-days: 7
          if-no-files-found: error

      - name: ðŸ§¾ Confirm artifact file exists
        if: always()
        run: |
          echo "ðŸ“„ gitleaks-report.json size:"
          ls -la gitleaks-report.json || true
          echo "ðŸ”Ž head:"
          head -c 200 gitleaks-report.json || true
          echo ""

      - name: ðŸ§° Prepare tools
        run: |
          set -euo pipefail
          echo "ðŸ§° Tools versions"
          curl --version | head -n 1

      - name: ðŸŒ Check Public URLs (Portfolio + SecureVault)
        id: public-urls
        run: |
          set -euo pipefail

          URLS=(
            "https://portfolio.freijstack.com"
            "https://christophe-freijanes.github.io/freijstack/"
            "https://vault.freijstack.com"
          )

          echo "## ðŸŒ Public URLs" >> "$GITHUB_STEP_SUMMARY"

          for url in "${URLS[@]}"; do
            echo "ðŸ”Ž Checking $url ..."

            # -L pour suivre redirects (plus rÃ©aliste en prod)
            code=$(
              curl -s -L -o /dev/null -w "%{http_code}" \
                --max-time 15 \
                --retry 2 --retry-delay 2 --retry-all-errors \
                "$url" || echo "000"
            )

            if [ "$code" = "200" ] || [ "$code" = "301" ] || [ "$code" = "302" ]; then
              echo "âœ… $url OK (HTTP $code)"
              echo "- âœ… $url (HTTP $code)" >> "$GITHUB_STEP_SUMMARY"
            else
              echo "âŒ $url DOWN (HTTP $code)"
              echo "- âŒ $url (HTTP $code)" >> "$GITHUB_STEP_SUMMARY"
              exit 1
            fi
          done

      - name: ðŸ”Ž Check Backend SecureVault API (/api/health)
        id: backend
        run: |
          set -euo pipefail
          echo "## ðŸ§  Backend API" >> "$GITHUB_STEP_SUMMARY"

          url="https://vault-api.freijstack.com/api/health"
          echo "ðŸ”Ž Checking $url ..."

          code=$(
            curl -s -o /dev/null -w "%{http_code}" \
              --max-time 10 \
              --retry 2 --retry-delay 2 --retry-all-errors \
              "$url" || echo "000"
          )

          if [ "$code" = "200" ]; then
            echo "âœ… Backend API OK (HTTP $code)"
            echo "status=healthy" >> "$GITHUB_OUTPUT"
            echo "- âœ… API healthy (HTTP $code)" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "âŒ Backend API DOWN (HTTP $code)"
            echo "status=unhealthy" >> "$GITHUB_OUTPUT"
            echo "- âŒ API unhealthy (HTTP $code)" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: ðŸ” Setup SSH (for DB check)
        id: ssh
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # host key -> known_hosts dÃ©diÃ©
          ssh-keyscan -H "${{ secrets.VPS_SSH_HOST }}" >> ~/.ssh/known_hosts

          # Quick SSH sanity check (timeout dur)
          ssh -i ~/.ssh/deploy_key \
            -o BatchMode=yes \
            -o ConnectTimeout=10 \
            -o ServerAliveInterval=5 \
            -o ServerAliveCountMax=2 \
            -o StrictHostKeyChecking=yes \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}" "echo 'âœ… SSH OK'"

      - name: ðŸ—„ï¸ Check Database Connectivity (pg_isready)
        id: database
        run: |
          set -euo pipefail
          echo "## ðŸ—„ï¸ Database" >> "$GITHUB_STEP_SUMMARY"

          SSH="ssh -i ~/.ssh/deploy_key -o BatchMode=yes -o ConnectTimeout=10 -o ServerAliveInterval=5 -o ServerAliveCountMax=2 -o StrictHostKeyChecking=yes -o UserKnownHostsFile=~/.ssh/known_hosts ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"
          PROD_DIR="/srv/www/securevault/saas/securevault"

          echo "ðŸ—„ï¸ Checking PostgreSQL (pg_isready)..."

          $SSH "cd '$PROD_DIR' && docker compose ps" || true

          db_status=$(
            $SSH "cd '$PROD_DIR' && docker compose exec -T postgres pg_isready -U securevault" 2>&1 || echo "FAILED"
          )

          if echo "$db_status" | grep -q "accepting connections"; then
            echo "âœ… Database OK"
            echo "status=healthy" >> "$GITHUB_OUTPUT"
            echo "- âœ… DB accepting connections" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "âŒ Database DOWN"
            echo "ðŸ”Ž pg_isready output: $db_status"
            echo "status=unhealthy" >> "$GITHUB_OUTPUT"
            echo "- âŒ DB not ready" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: ðŸ§¹ Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key || true

  auto-heal:
    name: ðŸ”§ Auto-Heal Production
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: health-check

    if: >
      always() &&
      needs.health-check.result == 'failure' &&
      (
        github.event_name == 'schedule' ||
        (github.event_name == 'workflow_dispatch' && inputs.auto_heal == true)
      )

    steps:
      - name: ðŸ” Setup SSH
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "${{ secrets.VPS_SSH_HOST }}" >> ~/.ssh/known_hosts

name: ðŸŽ¯ Deploy Queue (Orchestrator)

on:
  workflow_call:
    inputs:
      app_name:
        description: 'Application name (portfolio, securevault, registry, etc.)'
        required: true
        type: string
      environment:
        description: 'Target environment (staging or production)'
        required: true
        type: string
      deploy_dir:
        description: 'VPS deployment directory'
        required: true
        type: string
      project_path:
        description: 'Project subdirectory (e.g., saas/portfolio)'
        required: false
        type: string
        default: ''
      docker_compose_file:
        description: 'Docker Compose file to use'
        required: false
        type: string
        default: 'docker-compose.yml'
      run_migrations:
        description: 'Run database migrations after deploy'
        required: false
        type: boolean
        default: false
      custom_script:
        description: 'Custom deployment script (bash)'
        required: false
        type: string
        default: ''
    secrets:
      VPS_SSH_KEY:
        required: true
      VPS_SSH_HOST:
        required: true
      VPS_SSH_USER:
        required: true
      REGISTRY_PASSWORD_STAGING:
        required: false
      REGISTRY_USER_STAGING:
        required: false
      REGISTRY_USER_PROD:
        required: false
      REGISTRY_PASSWORD_PROD:
        required: false

# Global concurrency: only one deployment at a time across ALL apps
concurrency:
  group: vps-ssh-deploy
  cancel-in-progress: false

permissions:
  contents: read
  actions: read

jobs:
  deploy:
    name: ðŸš€ Deploy ${{ inputs.app_name }} to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment:
      name: ${{ inputs.environment }}

    steps:
      - name: â±ï¸ Staggered Start (avoid SSH collisions)
        run: |
          # Random delay between 5-20s to stagger parallel deployments
          DELAY=$((5 + RANDOM % 16))
          echo "ðŸ•’ Waiting ${DELAY}s to avoid SSH collision..."
          sleep $DELAY

      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ” Setup SSH
        run: |
          set -euo pipefail

          # Validate secrets
          if [ -z "${{ secrets.VPS_SSH_KEY }}" ]; then
            echo "âŒ VPS_SSH_KEY secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.VPS_SSH_HOST }}" ]; then
            echo "âŒ VPS_SSH_HOST secret is not set"
            exit 1
          fi

          # Setup SSH key
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Scan SSH host keys with retry (5 attempts); if all fail, proceed with relaxed host-key checking
          SSH_SCAN_FAILED=1
          echo "ðŸ” Scanning SSH host keys for ${{ secrets.VPS_SSH_HOST }}..."
          for i in {1..5}; do
            if ssh-keyscan -H "${{ secrets.VPS_SSH_HOST }}" >> ~/.ssh/known_hosts 2>/tmp/ssh-scan-err; then
              echo "âœ… SSH host keys retrieved (attempt $i/5)"
              SSH_SCAN_FAILED=0
              break
            else
              echo "âš ï¸ Attempt $i/5 failed:"
              cat /tmp/ssh-scan-err || true
              sleep 3
            fi
          done

          SSH_OPTIONS="-o StrictHostKeyChecking=yes"
          if [ $SSH_SCAN_FAILED -eq 1 ]; then
            echo "âš ï¸ Proceeding without host key verification (scan failed after 5 attempts)"
            echo "   Check: VPS firewall, SSH port 22, VPS_SSH_HOST secret"
            SSH_OPTIONS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
          fi

          # Persist for subsequent steps
          echo "SSH_OPTIONS=$SSH_OPTIONS" >> "$GITHUB_ENV"

      - name: ðŸ”’ Mask sensitive values
        run: |
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}"
          echo "::add-mask::${{ secrets.VPS_SSH_HOST }}"

      - name: ðŸš€ Deploy ${{ inputs.app_name }}
        run: |
          set -euo pipefail

          # Ensure SSH options are defined even if previous step failed to export
          SSH_OPTIONS="${SSH_OPTIONS:--o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null}"

          echo "ðŸ“¦ Deploying ${{ inputs.app_name }} to ${{ inputs.environment }}..."
          echo "ðŸ“‚ Deploy directory: ${{ inputs.deploy_dir }}"

          SSH_TARGET="${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"

          # Export variables for remote script
          REMOTE_ENV="APP_NAME='${{ inputs.app_name }}' \
          ENVIRONMENT='${{ inputs.environment }}' \
          DEPLOY_DIR='${{ inputs.deploy_dir }}' \
          PROJECT_PATH='${{ inputs.project_path }}' \
          COMPOSE_FILE='${{ inputs.docker_compose_file }}' \
          GITHUB_REPO='${{ github.repository }}' \
          GITHUB_REF='${{ github.ref }}' \
          REGISTRY_USER_STAGING='${{ secrets.REGISTRY_USER_STAGING }}' \
          REGISTRY_PASSWORD_STAGING='${{ secrets.REGISTRY_PASSWORD_STAGING }}' \
          REGISTRY_USER_PROD='${{ secrets.REGISTRY_USER_PROD }}' \
          REGISTRY_PASSWORD_PROD='${{ secrets.REGISTRY_PASSWORD_PROD }}'"

          if [ -n "${{ inputs.custom_script }}" ]; then
            # Use custom deployment script if provided
            echo "ðŸ”§ Using custom deployment script..."
            echo "${{ inputs.custom_script }}" | ssh ${SSH_OPTIONS} -i ~/.ssh/deploy_key "${SSH_TARGET}" "${REMOTE_ENV}" bash
          else
            # Generic deployment script
            ssh ${SSH_OPTIONS} -i ~/.ssh/deploy_key "${SSH_TARGET}" "${REMOTE_ENV}" bash <<'DEPLOY_SCRIPT'
            set -e
            echo "ðŸš€ Starting deployment for $APP_NAME ($ENVIRONMENT)..."

            # Create deploy directory
            mkdir -p "$DEPLOY_DIR"
            cd "$DEPLOY_DIR"

            # Clone or update repository
            if [ -d ".git" ]; then
              echo "âœ… Repository exists, pulling latest changes..."
              git fetch origin
              git reset --hard "origin/${GITHUB_REF##*/}"
              git clean -fd
            else
              # Clean directory if it exists but is not a git repo
              if [ "$(ls -A .)" ]; then
                echo "âš ï¸ Directory exists but is not a git repository, cleaning..."
                rm -rf ..?* .[!.]* *
              fi
              echo "ðŸ“¥ Cloning repository..."
              BRANCH="${GITHUB_REF##*/}"
              git clone -b "${BRANCH}" "https://github.com/${GITHUB_REPO}.git" .
            fi

            # Navigate to project subdirectory if specified
            if [ -n "$PROJECT_PATH" ]; then
              echo "ðŸ“‚ Entering project directory: $PROJECT_PATH"
              cd "$PROJECT_PATH"
            fi

            # Create required directories for volume bind mounts (if they don't exist)
            if grep -q "device: ./data" "$COMPOSE_FILE" 2>/dev/null; then
              echo "ðŸ“ Ensuring data directory exists..."
              mkdir -p data
            fi

            # Use per-app/per-env project name to avoid reusing stale volumes
            # Skip for services with fixed container_name to avoid breaking existing deployments
            if ! grep -q "container_name:" "$COMPOSE_FILE" 2>/dev/null; then
              export COMPOSE_PROJECT_NAME="${APP_NAME}-${ENVIRONMENT}"
              echo "ðŸ“¦ Using project name: $COMPOSE_PROJECT_NAME"
            else
              echo "âš ï¸ Skipping COMPOSE_PROJECT_NAME (fixed container names detected)"
            fi

            # Generate .htpasswd for registry if needed
            if [ "$APP_NAME" = "registry" ]; then
              if [ "$ENVIRONMENT" = "staging" ]; then
                if [ -z "$REGISTRY_USER_STAGING" ] || [ -z "$REGISTRY_PASSWORD_STAGING" ]; then
                  echo "âŒ Error: REGISTRY_USER_STAGING and REGISTRY_PASSWORD_STAGING are required for staging registry deployment"
                  exit 1
                fi
                REGISTRY_USERNAME="$REGISTRY_USER_STAGING"
                REGISTRY_PASSWORD="$REGISTRY_PASSWORD_STAGING"
                echo "ðŸ‘¤ Using staging user: $REGISTRY_USERNAME"
              elif [ "$ENVIRONMENT" = "production" ]; then
                if [ -z "$REGISTRY_USER_PROD" ] || [ -z "$REGISTRY_PASSWORD_PROD" ]; then
                  echo "âŒ Error: REGISTRY_USER_PROD and REGISTRY_PASSWORD_PROD are required for production registry deployment"
                  exit 1
                fi
                REGISTRY_USERNAME="$REGISTRY_USER_PROD"
                REGISTRY_PASSWORD="$REGISTRY_PASSWORD_PROD"
                echo "ðŸ‘¤ Using production user: $REGISTRY_USERNAME"
              else
                echo "âŒ Error: Unknown environment $ENVIRONMENT"
                exit 1
              fi

              echo "ðŸ” Generating .htpasswd for registry authentication..."
              mkdir -p data
              docker run --rm \
                --entrypoint htpasswd \
                httpd:2 \
                -Bbn "$REGISTRY_USERNAME" "$REGISTRY_PASSWORD" > .htpasswd
              echo "âœ… .htpasswd generated successfully"
              ls -lh .htpasswd

              # Create .env file for docker-compose to use
              echo "ðŸ“ Creating .env file for docker-compose..."
              echo "REGISTRY_USER_PROD=$REGISTRY_USER_PROD" > .env
              echo "REGISTRY_PASSWORD_PROD=$REGISTRY_PASSWORD_PROD" >> .env
              echo "REGISTRY_USER_STAGING=$REGISTRY_USER_STAGING" >> .env
              echo "REGISTRY_PASSWORD_STAGING=$REGISTRY_PASSWORD_STAGING" >> .env
              echo "âœ… .env file created successfully"
            fi

            # Deploy with Docker Compose
            echo "ðŸ³ Deploying with $COMPOSE_FILE..."
            if [ -f "$COMPOSE_FILE" ]; then
              # Always stop the other registry environment before starting this one (shared volume scenario)
              if [ "$APP_NAME" = "registry" ]; then
                if [ "$ENVIRONMENT" = "production" ]; then
                  echo "ðŸ›‘ Stopping staging registry before starting production registry..."
                  docker compose -f docker-compose.staging.yml down || true
                elif [ "$ENVIRONMENT" = "staging" ]; then
                  echo "ðŸ›‘ Stopping production registry before starting staging registry..."
                  docker compose -f docker-compose.prod.yml down || true
                fi
              fi

              if [ "$ENVIRONMENT" = "production" ]; then
                echo "ðŸ”„ Production deployment: updating containers without touching volumes..."
                # Docker login avant pull
                if [ -n "$REGISTRY_USER_PROD" ] && [ -n "$REGISTRY_PASSWORD_PROD" ]; then
                  echo "$REGISTRY_PASSWORD_PROD" | docker login registry.freijstack.com -u "$REGISTRY_USER_PROD" --password-stdin
                else
                  echo "âš ï¸ REGISTRY_USER_PROD ou REGISTRY_PASSWORD_PROD non dÃ©fini, pull sans login."
                fi
                # Pull latest images
                docker compose -f "$COMPOSE_FILE" pull
                # Recreate containers without stopping them (zero-downtime if possible)
                docker compose -f "$COMPOSE_FILE" up -d --remove-orphans
              else
                echo "ðŸ›‘ Staging deployment: cleaning containers but preserving data volumes..."
                docker compose -f "$COMPOSE_FILE" down --remove-orphans || true

                # Force remove any lingering containers with names matching the app
                docker ps -aq --filter "name=${APP_NAME}" | xargs -r docker rm -f 2>/dev/null || true

                docker compose -f "$COMPOSE_FILE" pull
                docker compose -f "$COMPOSE_FILE" up -d --build --remove-orphans
              fi

              echo "â³ Waiting 10s for services to start..."
              sleep 10

              echo "ðŸ“Š Container status:"
              docker compose -f "$COMPOSE_FILE" ps

              echo "ðŸ“œ Recent logs:"
              docker compose -f "$COMPOSE_FILE" logs --tail=20
            else
              echo "âŒ Docker Compose file not found: $COMPOSE_FILE"
              exit 1
            fi

            echo "âœ… Deployment completed for $APP_NAME!"
          DEPLOY_SCRIPT
          fi

      - name: ðŸ—„ï¸ Run Migrations
        if: inputs.run_migrations
        run: |
          echo "ðŸ—„ï¸ Running database migrations..."
          ssh ${SSH_OPTIONS} -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} \
            "cd ${{ inputs.deploy_dir }}/${{ inputs.project_path }} && \
            docker compose exec -T backend npm run migrate 2>/dev/null || \
            docker compose exec -T app npm run migrate 2>/dev/null || \
            echo 'âš ï¸ No migration script found or failed'"

      - name: âœ… Deployment Summary
        if: success()
        run: |
          echo "## âœ… Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: ${{ inputs.app_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Directory**: \`${{ inputs.deploy_dir }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Compose File**: \`${{ inputs.docker_compose_file }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Migrations**: ${{ inputs.run_migrations && 'âœ… Executed' || 'â­ï¸ Skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ¯ Deployed by: \`${{ github.actor }}\`" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“ Commit: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY

      - name: âŒ Deployment Failed
        if: failure()
        run: |
          echo "## âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: ${{ inputs.app_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check logs above for details." >> $GITHUB_STEP_SUMMARY
          exit 1

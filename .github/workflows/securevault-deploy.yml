name: üîê Deploy SecureVault

on:
  push:
    branches: [develop]  # Auto-deploy staging only
    paths:
      - 'saas/securevault/**'
      - '.github/workflows/securevault-deploy.yml'
  pull_request:
    branches: [develop, master]
    paths:
      - 'saas/securevault/**'
      - '.github/workflows/securevault-deploy.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      restart_traefik:
        description: 'Red√©marrer Traefik apr√®s d√©ploiement'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/securevault
  # Paths
  PROJECT_PATH: saas/securevault
  VPS_DEPLOY_DIR_PROD: /srv/www/securevault
  VPS_DEPLOY_DIR_STAGING: /srv/www/securevault-staging
  VPS_ENV_FILE_PROD: /srv/www/securevault/.env
  VPS_ENV_FILE_STAGING: /srv/www/securevault-staging/.env
  # Branches
  BRANCH_PROD: master
  BRANCH_STAGING: develop
  # Container names
  CONTAINER_PREFIX_PROD: securevault
  CONTAINER_PREFIX_STAGING: securevault-staging
  # Networks
  NETWORK_PROD: securevault_network
  NETWORK_STAGING: securevault_staging_network
  # Domains
  FRONTEND_DOMAIN_PROD: vault.freijstack.com
  BACKEND_DOMAIN_PROD: vault-api.freijstack.com
  FRONTEND_DOMAIN_STAGING: vault-staging.freijstack.com
  BACKEND_DOMAIN_STAGING: vault-api-staging.freijstack.com

jobs:
  validate:
    name: ‚úÖ Validate VPS Configuration
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' && github.ref == 'refs/heads/develop') || github.event_name == 'workflow_dispatch'

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: üîí Mask sensitive values
        run: |
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}"
          echo "::add-mask::${{ secrets.VPS_SSH_HOST }}"
          # Mask combined user@host too
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"

      - name: üåê Check DNS Configuration
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üîç Checking DNS records for $TARGET_ENV..."
          
          # Fonction pour v√©rifier un DNS
          check_dns() {
            DOMAIN=$1
            echo "Checking $DOMAIN..."
            if dig +short $DOMAIN | grep -q '[0-9]'; then
              IP=$(dig +short $DOMAIN | head -n1)
              echo "‚úÖ $DOMAIN ‚Üí $IP"
              return 0
            else
              echo "‚ùå $DOMAIN not configured"
              return 1
            fi
          }
          
          FAILED=0
          
          if [ "$TARGET_ENV" = "production" ]; then
            check_dns "${{ env.FRONTEND_DOMAIN_PROD }}" || FAILED=1
            check_dns "${{ env.BACKEND_DOMAIN_PROD }}" || FAILED=1
          else
            check_dns "${{ env.FRONTEND_DOMAIN_STAGING }}" || FAILED=1
            check_dns "${{ env.BACKEND_DOMAIN_STAGING }}" || FAILED=1
          fi
          
          if [ $FAILED -eq 1 ]; then
            echo ""
            echo "‚ö†Ô∏è Some DNS records are missing. Please configure them:"
            echo "   - Add A records pointing to your VPS IP"
            echo "   - Wait 5-10 minutes for propagation"
            exit 1
          fi
          
          echo "‚úÖ All DNS records configured correctly"

      - name: üîç Check VPS Prerequisites
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          # D√©terminer les chemins selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            ENV_FILE="${{ env.VPS_ENV_FILE_PROD }}"
          else
            ENV_FILE="${{ env.VPS_ENV_FILE_STAGING }}"
          fi
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} << VPS_CHECK
            set -e
            echo "üîç Checking VPS configuration..."
            echo "Environment: $TARGET_ENV"
            echo ""

            # Mask sensitive values from existing .env if present
            echo "üîí Applying runtime masks for sensitive values..."
            if [ -f "$ENV_FILE" ]; then
              for VAR in DB_PASSWORD JWT_SECRET ENCRYPTION_KEY POSTGRES_PASSWORD; do
                VALUE=\$(grep -E "^\$VAR=" "$ENV_FILE" | cut -d'=' -f2-)
                if [ -n "\$VALUE" ]; then
                  echo "::add-mask::\$VALUE"
                fi
              done
            fi
            
            # 1. V√©rifier Docker
            echo "1Ô∏è‚É£ Checking Docker..."
            if command -v docker &> /dev/null; then
              DOCKER_VERSION=$(docker --version)
              echo "‚úÖ Docker installed: $DOCKER_VERSION"
            else
              echo "‚ùå Docker not installed"
              exit 1
            fi
            
            # 2. V√©rifier Docker Compose
            echo ""
            echo "2Ô∏è‚É£ Checking Docker Compose..."
            if docker compose version &> /dev/null; then
              COMPOSE_VERSION=$(docker compose version)
              echo "‚úÖ Docker Compose installed: $COMPOSE_VERSION"
            else
              echo "‚ùå Docker Compose not installed"
              exit 1
            fi
            
            # 3. V√©rifier le r√©seau web
            echo ""
            echo "3Ô∏è‚É£ Checking Docker network 'web'..."
            if docker network ls | grep -q "web"; then
              echo "‚úÖ Network 'web' exists"
            else
              echo "‚ö†Ô∏è Network 'web' not found, creating it..."
              docker network create web
              echo "‚úÖ Network 'web' created successfully"
            fi
            
            # 4. V√©rifier Traefik
            echo ""
            echo "4Ô∏è‚É£ Checking Traefik..."
            TRAEFIK_CONTAINER=$(docker ps --format '{{.Names}}' | grep -i 'traefik' | head -n1)
            if [ -n "$TRAEFIK_CONTAINER" ]; then
              TRAEFIK_STATUS=$(docker ps --filter "name=$TRAEFIK_CONTAINER" --format "{{.Status}}")
              echo "‚úÖ Traefik is running: $TRAEFIK_STATUS (container: $TRAEFIK_CONTAINER)"
            else
              echo "‚ö†Ô∏è Traefik not running"
              echo "   Setup steps:"
              echo "   1. cd /root"
              echo "   2. docker network create web 2>/dev/null || true"
              echo "   3. docker volume create traefik_data 2>/dev/null || true"
              echo "   4. cp freijstack/base-infra/docker-compose.yml ."
              echo "   5. docker compose up -d"
              exit 1
            fi
            
            # 5. V√©rifier le fichier .env
            echo ""
            echo "5Ô∏è‚É£ Checking .env file..."
            if [ -f "\$ENV_FILE" ]; then
              echo "‚úÖ .env file exists at \$ENV_FILE"
              
              # D√©terminer les domaines selon l'environnement
              if [ "$TARGET_ENV" = "production" ]; then
                API_DOM="vault-api.freijstack.com"
                FRONTEND_DOM="vault.freijstack.com"
                FRONTEND_U="https://vault.freijstack.com"
                PROJECT_NAME="securevault"
              else
                API_DOM="vault-api-staging.freijstack.com"
                FRONTEND_DOM="vault-staging.freijstack.com"
                FRONTEND_U="https://vault-staging.freijstack.com"
                PROJECT_NAME="securevault-staging"
              fi
              
              # V√©rifier et ajouter les variables manquantes
              UPDATED=0
              
              if ! grep -q "^COMPOSE_PROJECT_NAME=" "$ENV_FILE"; then
                echo "" >> "$ENV_FILE"
                echo "COMPOSE_PROJECT_NAME=$PROJECT_NAME" >> "$ENV_FILE"
                echo "‚ö†Ô∏è Added missing COMPOSE_PROJECT_NAME=$PROJECT_NAME"
                UPDATED=1
              fi
              
              if ! grep -q "^API_DOMAIN=" "$ENV_FILE"; then
                echo "API_DOMAIN=$API_DOM" >> "$ENV_FILE"
                echo "‚ö†Ô∏è Added missing API_DOMAIN=$API_DOM"
                UPDATED=1
              fi
              
              if ! grep -q "^FRONTEND_DOMAIN=" "$ENV_FILE"; then
                echo "FRONTEND_DOMAIN=$FRONTEND_DOM" >> "$ENV_FILE"
                echo "‚ö†Ô∏è Added missing FRONTEND_DOMAIN=$FRONTEND_DOM"
                UPDATED=1
              fi
              
              if ! grep -q "^FRONTEND_URL=" "$ENV_FILE"; then
                echo "FRONTEND_URL=$FRONTEND_U" >> "$ENV_FILE"
                echo "‚ö†Ô∏è Added missing FRONTEND_URL=$FRONTEND_U"
                UPDATED=1
              fi
              
              # V√©rifier les secrets critiques
              MISSING_SECRETS=""
              for VAR in DB_PASSWORD JWT_SECRET ENCRYPTION_KEY; do
                if ! grep -q "^\${VAR}=" "\$ENV_FILE"; then
                  MISSING_SECRETS="\$MISSING_SECRETS \$VAR"
                fi
              done
              
              if [ -n "\$MISSING_SECRETS" ]; then
                echo "‚ùå Missing critical secrets:\$MISSING_SECRETS"
                echo "   These must be added manually for security reasons"
                exit 1
              fi
              
              if [ $UPDATED -eq 1 ]; then
                echo "‚úÖ .env file updated with missing domain variables"
              else
                echo "‚úÖ All required variables present"
              fi
            else
              echo "‚ö†Ô∏è .env file not found, creating it with generated secrets..."
              
              # Cr√©er le r√©pertoire si n√©cessaire
              mkdir -p \$(dirname "\$ENV_FILE")
              
              # G√©n√©rer les secrets
              DB_PASS=\$(openssl rand -hex 32)
              JWT_SEC=\$(openssl rand -hex 32)
              ENC_KEY=\$(openssl rand -hex 32)
              
              # D√©terminer les domaines selon l'environnement
              if [ "$TARGET_ENV" = "production" ]; then
                API_DOM="vault-api.freijstack.com"
                FRONTEND_DOM="vault.freijstack.com"
                FRONTEND_U="https://vault.freijstack.com"
                PROJECT_NAME="securevault"
              else
                API_DOM="vault-api-staging.freijstack.com"
                FRONTEND_DOM="vault-staging.freijstack.com"
                FRONTEND_U="https://vault-staging.freijstack.com"
                PROJECT_NAME="securevault-staging"
              fi
              
              # Cr√©er le fichier .env avec les secrets g√©n√©r√©s
              {
                echo "# Auto-generated secrets for SecureVault $TARGET_ENV"
                echo "# Generated on \$(date)"
                echo ""
                echo "COMPOSE_PROJECT_NAME=\\$PROJECT_NAME"
                echo ""
                echo "DB_PASSWORD=\$DB_PASS"
                echo "JWT_SECRET=\$JWT_SEC"
                echo "ENCRYPTION_KEY=\$ENC_KEY"
                echo ""
                echo "# Domain configuration"
                echo "API_DOMAIN=\$API_DOM"
                echo "FRONTEND_DOMAIN=\$FRONTEND_DOM"
                echo "FRONTEND_URL=\$FRONTEND_U"
              } > "\\$ENV_FILE"
              
              chmod 600 "\$ENV_FILE"
              echo "‚úÖ .env file created at \$ENV_FILE with secure permissions"
            fi
            
            # 6. V√©rifier les permissions
            echo ""
            echo "6Ô∏è‚É£ Checking .env permissions..."
            PERMS=\$(stat -c %a "\$ENV_FILE" 2>/dev/null || stat -f %A "\$ENV_FILE")
            if [ "\\$PERMS" = "600" ]; then
              echo "‚úÖ .env permissions are secure (600)"
            else
              echo "‚ö†Ô∏è .env permissions are \$PERMS (should be 600)"
              echo "   Fix with: chmod 600 \$ENV_FILE"
            fi
            
            echo ""
            echo "‚úÖ All VPS prerequisites validated for $TARGET_ENV!"
          VPS_CHECK

      - name: ‚úÖ Validation Summary
        if: success()
        run: |
          echo "‚úÖ VPS Configuration Validated Successfully!"
          echo ""
          echo "Environment: ${{ github.ref == 'refs/heads/master' && 'Production' || 'Staging' }}"
          echo "Ready for deployment üöÄ"

      - name: ‚ùå Validation Failed
        if: failure()
        run: |
          echo "‚ùå VPS Configuration Validation Failed"
          echo ""
          echo "Please fix the issues above before deploying."
          echo "Review the logs for specific error messages."
          exit 1

  test:
    name: üß™ Test & Build
    runs-on: ubuntu-latest
    needs: validate
    permissions:
      contents: read
      security-events: write

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Set up Node.js (Backend)
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: 'saas/securevault/backend/package.json'

      - name: üß™ Test Backend
        working-directory: saas/securevault/backend
        run: |
          npm install
          npm test -- --passWithNoTests || true
        continue-on-error: true

      - name: Lint Backend
        working-directory: saas/securevault/backend
        run: npm run lint --if-present
        continue-on-error: true

      - name: üîß Set up Node.js (Frontend)
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: 'saas/securevault/frontend/package.json'

      - name: üß™ Test Frontend
        working-directory: saas/securevault/frontend
        run: |
          npm install
          npm test -- --passWithNoTests || true
        continue-on-error: true

      - name: üê≥ Build Docker images
        working-directory: saas/securevault
        run: |
          docker build -t securevault-backend:test ./backend
          docker build -t securevault-frontend:test ./frontend

      - name: üîç Run Trivy vulnerability scan (Backend)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'securevault-backend:test'
          format: 'sarif'
          output: 'trivy-backend.sarif'
        continue-on-error: true

      - name: üîç Run Trivy vulnerability scan (Frontend)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'securevault-frontend:test'
          format: 'sarif'
          output: 'trivy-frontend.sarif'
        continue-on-error: true

      - name: Upload Trivy results to GitHub Security (Backend)
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-backend.sarif'
          category: 'securevault-backend'
        continue-on-error: true

      - name: Upload Trivy results to GitHub Security (Frontend)
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-frontend.sarif'
          category: 'securevault-frontend'
        continue-on-error: true

  cleanup:
    name: üßπ Cleanup Old Containers
    runs-on: ubuntu-latest
    needs: test
    if: (github.event_name == 'push' && github.ref == 'refs/heads/develop') || github.event_name == 'workflow_dispatch'

    steps:
      - name: üîê Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: üîí Mask sensitive values
        run: |
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}"
          echo "::add-mask::${{ secrets.VPS_SSH_HOST }}"
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"

      - name: üßπ Force remove old containers
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üéØ Cleanup for environment: $TARGET_ENV"
          
          # D√©terminer les conteneurs et r√©seaux selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            CONTAINERS="${{ env.CONTAINER_PREFIX_PROD }}-backend ${{ env.CONTAINER_PREFIX_PROD }}-frontend ${{ env.CONTAINER_PREFIX_PROD }}-postgres"
            NETWORKS="${{ env.NETWORK_PROD }}"
          else
            CONTAINERS="${{ env.CONTAINER_PREFIX_STAGING }}-backend ${{ env.CONTAINER_PREFIX_STAGING }}-frontend ${{ env.CONTAINER_PREFIX_STAGING }}-postgres"
            NETWORKS="${{ env.NETWORK_STAGING }}"
          fi
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} << CLEANUP_SCRIPT
            set -e
            echo "üßπ Cleaning up old containers and networks..."
            echo "Environment: $TARGET_ENV"
            
            # Arr√™ter et supprimer les conteneurs s'ils existent
            for CONTAINER in $CONTAINERS; do
              if docker ps -a --format '{{.Names}}' | grep -q "^\${CONTAINER}\$"; then
                echo "Removing container: \$CONTAINER"
                docker rm -f "\$CONTAINER" || true
              else
                echo "Container \$CONTAINER does not exist, skipping"
              fi
            done
            
            # Supprimer les r√©seaux orphelins s'ils existent
            for NETWORK in $NETWORKS; do
              if docker network ls --format '{{.Name}}' | grep -q "^${NETWORK}$"; then
                echo "Removing network: $NETWORK"
                docker network rm "$NETWORK" || true
              else
                echo "Network $NETWORK does not exist, skipping"
              fi
            done
            
            echo "‚úÖ Cleanup complete (volumes preserved for data safety)"
          CLEANUP_SCRIPT

  deploy:
    name: üöÄ Deploy to VPS
    runs-on: ubuntu-latest
    needs: cleanup
    if: (github.event_name == 'push' && github.ref == 'refs/heads/develop') || github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ github.ref == 'refs/heads/master' && 'production' || 'staging' }}
      url: ${{ github.ref == 'refs/heads/master' && 'https://vault.freijstack.com' || 'https://vault-staging.freijstack.com' }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: üîí Mask sensitive values
        run: |
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}"
          echo "::add-mask::${{ secrets.VPS_SSH_HOST }}"
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"

      - name: üöÄ Deploy to VPS
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üéØ Target environment: $TARGET_ENV"
          
          # D√©terminer les chemins selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_PROD }}"
            ENV_FILE="${{ env.VPS_ENV_FILE_PROD }}"
            BRANCH="${{ env.BRANCH_PROD }}"
            ENV_TEMPLATE=".env.production"
          else
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_STAGING }}"
            ENV_FILE="${{ env.VPS_ENV_FILE_STAGING }}"
            BRANCH="${{ env.BRANCH_STAGING }}"
            ENV_TEMPLATE=".env.staging"
          fi
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} << DEPLOY_SCRIPT
            set -e
            echo "üöÄ Starting SecureVault deployment..."
            echo "üéØ Deploying to: $TARGET_ENV"
            echo "üìÇ Deploy directory: $DEPLOY_DIR"
            
            # Cloner/mettre √† jour le repo
            if [ -d "$DEPLOY_DIR/.git" ]; then
              echo "‚úÖ Repository already exists, pulling latest changes..."
              cd "$DEPLOY_DIR"
              git fetch origin
              git reset --hard origin/$BRANCH
              git clean -fd
            else
              echo "üì• Cloning repository for the first time..."
              # Supprimer le r√©pertoire s'il existe mais n'est pas un repo Git
              if [ -d "$DEPLOY_DIR" ]; then
                echo "üßπ Cleaning existing directory..."
                rm -rf "$DEPLOY_DIR"
              fi
              git clone -b \$BRANCH https://github.com/${{ github.repository }}.git "\$DEPLOY_DIR"
              cd "\$DEPLOY_DIR"
            fi
            
            # Naviguer vers securevault
            cd ${{ env.PROJECT_PATH }}
            
            echo "üìù Using environment template: \$ENV_TEMPLATE"
            
            # V√©rifier que le template existe dans le repo
            if [ ! -f "\$ENV_TEMPLATE" ]; then
              echo "‚ùå ERREUR: Template \$ENV_TEMPLATE manquant dans le repo"
              exit 1
            fi
            
            # Copier le template comme base
            cp "\$ENV_TEMPLATE" .env
            
            # V√©rifier et injecter les secrets depuis le fichier .env du VPS
            if [ -f "\$ENV_FILE" ]; then
              echo "üîê Injecting secrets from VPS .env file..."
              
              # Extraire les secrets critiques du fichier VPS
              for SECRET_VAR in POSTGRES_PASSWORD JWT_SECRET ENCRYPTION_KEY; do
                SECRET_VALUE=\$(grep -E "^\${SECRET_VAR}=" "\$ENV_FILE" 2>/dev/null | cut -d'=' -f2- || echo "")
                if [ -n "\$SECRET_VALUE" ]; then
                  # Remplacer dans le fichier .env local
                  if grep -q "^\${SECRET_VAR}=" .env; then
                    sed -i "s|^\${SECRET_VAR}=.*|\${SECRET_VAR}=\${SECRET_VALUE}|" .env
                  else
                    echo "\${SECRET_VAR}=\${SECRET_VALUE}" >> .env
                  fi
                  echo "  ‚úÖ Injected \${SECRET_VAR}"
                else
                  echo "  ‚ö†Ô∏è \${SECRET_VAR} not found in VPS .env, using template default"
                fi
              done
            else
              echo "‚ö†Ô∏è VPS .env file not found at \$ENV_FILE"
              echo "   Using template defaults (INSECURE for production!)"
            fi
            
            echo "üîß Building and starting containers..."
            docker compose pull
            docker compose up -d --build --remove-orphans
            
            # Attendre que les services soient pr√™ts
            sleep 10
            
            # V√©rifier la sant√©
            echo "üè• Checking health..."
            docker compose ps
            
            echo "‚úÖ Deployment successful!"
            echo "üìä Logs:"
            docker compose logs --tail=20
          DEPLOY_SCRIPT

      - name: üîÑ Restart Traefik (optionnel)
        if: github.event_name == 'workflow_dispatch' && inputs.restart_traefik == true
        run: |
          echo "üîÑ Restarting Traefik as requested..."
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} << 'TRAEFIK_RESTART'
            set -e
            TRAEFIK_CONTAINER=$(docker ps --format '{{.Names}}' | grep -i 'traefik' | head -n1)
            if [ -z "$TRAEFIK_CONTAINER" ]; then
              echo "‚ùå Traefik container not found"
              exit 1
            fi
            echo "Restarting $TRAEFIK_CONTAINER..."
            docker restart "$TRAEFIK_CONTAINER"
            sleep 5
            echo "‚úÖ Traefik restarted"
          TRAEFIK_RESTART

      - name: Verify Deployment
        run: |
          ENVIRONMENT=${{ github.ref == 'refs/heads/master' && 'production' || 'staging' }}
          
          echo "üîç V√©rification du d√©ploiement sur $ENVIRONMENT..."
          sleep 5
          
          # V√©rifier que les conteneurs tournent sur le VPS
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} \
            'if [ "${{ github.ref }}" = "refs/heads/master" ]; then
              cd /srv/www/securevault/saas/securevault
              docker compose -f docker-compose.yml ps
            else
              cd /srv/www/securevault-staging/saas/securevault
              docker compose -f docker-compose.staging.yml ps
            fi'
          
          echo "‚úÖ D√©ploiement v√©rifi√© avec succ√®s!"

      - name: ‚úÖ Notify Deployment Success
        if: success()
        run: |
          echo "‚úÖ SecureVault deployment successful!"
          echo "Environment: ${{ github.ref == 'refs/heads/master' && 'production' || 'staging' }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"

      - name: ‚ùå Notify Deployment Failure
        if: failure()
        run: |
          echo "‚ùå SecureVault deployment failed!"
          echo "Check logs above for details"
          exit 1

  post-verify:
    name: üîé Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: üîí Mask sensitive values
        run: |
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}"
          echo "::add-mask::${{ secrets.VPS_SSH_HOST }}"
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"

      - name: üîç Inspect Traefik for routers
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üîç Checking Traefik routers in logs..."
          
          # D√©terminer les domaines selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            FRONTEND_DOM="${{ env.FRONTEND_DOMAIN_PROD }}"
            API_DOM="${{ env.BACKEND_DOMAIN_PROD }}"
          else
            FRONTEND_DOM="${{ env.FRONTEND_DOMAIN_STAGING }}"
            API_DOM="${{ env.BACKEND_DOMAIN_STAGING }}"
          fi

          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} << VERIFY_LOGS
            set -e
            TRAEFIK_CONTAINER=\$(docker ps --format '{{.Names}}' | grep -i 'traefik' | head -n1)
            if [ -z "\$TRAEFIK_CONTAINER" ]; then
              echo "‚ùå Traefik not running"
              exit 1
            fi
            echo "‚úÖ Found Traefik container: \$TRAEFIK_CONTAINER"
            echo "üìú Last Traefik logs (filtered):"
            docker logs --tail=300 "\$TRAEFIK_CONTAINER" | grep -E "($FRONTEND_DOM|$API_DOM|mytlschallenge|websecure)" || true
            echo "‚úÖ Log inspection done"
          VERIFY_LOGS

      - name: üåê HTTP checks (TLS & routes)
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          # D√©terminer les domaines selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            FRONTEND_DOM="${{ env.FRONTEND_DOMAIN_PROD }}"
            API_DOM="${{ env.BACKEND_DOMAIN_PROD }}"
          else
            FRONTEND_DOM="${{ env.FRONTEND_DOMAIN_STAGING }}"
            API_DOM="${{ env.BACKEND_DOMAIN_STAGING }}"
          fi

          check_url() {
            DOMAIN="$1"
            ATTEMPTS=3
            DELAY=10
            for i in $(seq 1 $ATTEMPTS); do
              # Accept self-signed certs temporarily with -k
              CODE=$(curl -sSLk -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 20 "https://$DOMAIN" || echo "000")
              echo "Attempt $i: $DOMAIN ‚Üí HTTP $CODE"
              case "$CODE" in
                200|301|302|404)
                  echo "‚úÖ $DOMAIN reachable (HTTP $CODE)"
                  return 0
                  ;;
                *)
                  sleep "$DELAY"
                  ;;
              esac
            done
            echo "‚ö†Ô∏è $DOMAIN not reachable with valid status after retries (last: $CODE)"
            return 1
          }

          FAILED=0
          check_url "$FRONTEND_DOM" || FAILED=1
          check_url "$API_DOM" || FAILED=1

          if [ $FAILED -eq 1 ]; then
            echo "‚ùå Post-deployment verification failed"
            exit 1
          fi
          echo "‚úÖ Post-deployment verification successful"

  notify:
    name: üì¢ Notify Status
    runs-on: ubuntu-latest
    needs: [validate, test, deploy, post-verify]
    if: always()
    
    steps:
      - name: Check overall status
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "üîç Pull Request - Validation Only"
            echo "‚úÖ Code validation and security checks completed"
            echo "üìã No deployment on pull requests"
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            echo "üß™ STAGING Environment - Push Event"
            echo "‚úÖ SecureVault staging deployment completed"
            echo "üìç https://vault-staging.freijstack.com"
            echo "üìç API: https://vault-api-staging.freijstack.com"
          elif [ "${{ github.ref }}" == "refs/heads/master" ]; then
            echo "üöÄ PRODUCTION Environment - Push Event"
            echo "‚úÖ SecureVault production deployment completed"
            echo "üéØ https://vault.freijstack.com"
            echo "üéØ API: https://vault-api.freijstack.com"
          else
            echo "‚ÑπÔ∏è Event: ${{ github.event_name }} on ${{ github.ref }}"
          fi

      - name: ‚úÖ Success Summary
        if: ${{ needs.validate.result == 'success' && needs.test.result == 'success' && needs.deploy.result == 'success' && needs.post-verify.result == 'success' }}
        run: |
          echo "‚úÖ All jobs completed successfully!"
          echo "üìä Validation: ‚úÖ"
          echo "üß™ Tests: ‚úÖ"
          echo "üöÄ Deployment: ‚úÖ"
          echo "üîé Post-verification: ‚úÖ"

      - name: ‚ö†Ô∏è Partial Success
        if: ${{ (needs.validate.result == 'failure' || needs.test.result == 'failure' || needs.deploy.result == 'failure' || needs.post-verify.result == 'failure') }}
        run: |
          echo "‚ö†Ô∏è Some jobs failed:"
          echo "Validation: ${{ needs.validate.result }}"
          echo "Tests: ${{ needs.test.result }}"
          echo "Deploy: ${{ needs.deploy.result }}"
          echo "Post-verify: ${{ needs.post-verify.result }}"

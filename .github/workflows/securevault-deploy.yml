name: üîê Deploy SecureVault

on:
  push:
    branches: [develop, master]  # Auto-deploy staging (develop) and production (master)
    paths:
      - 'saas/securevault/**'
      - '.github/workflows/securevault-deploy.yml'
  pull_request:
    branches: [develop, master]
    paths:
      - 'saas/securevault/**'
      - '.github/workflows/securevault-deploy.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      restart_traefik:
        description: 'Red√©marrer Traefik apr√®s d√©ploiement'
        required: false
        default: false
        type: boolean
      destroy_staging:
        description: 'üî• D√©truire Staging (ATTENTION!)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/securevault
  # Paths
  PROJECT_PATH: saas/securevault
  VPS_DEPLOY_DIR_PROD: /srv/www/securevault
  VPS_DEPLOY_DIR_STAGING: /srv/www/securevault-staging
  VPS_ENV_FILE_PROD: /srv/www/securevault/.env
  VPS_ENV_FILE_STAGING: /srv/www/securevault-staging/.env
  # Branches
  BRANCH_PROD: master
  BRANCH_STAGING: develop
  # Container names
  CONTAINER_PREFIX_PROD: securevault
  CONTAINER_PREFIX_STAGING: securevault-staging
  # Networks
  NETWORK_PROD: securevault_network
  NETWORK_STAGING: securevault_staging_network
  # Domains
  FRONTEND_DOMAIN_PROD: vault.freijstack.com
  BACKEND_DOMAIN_PROD: vault-api.freijstack.com
  FRONTEND_DOMAIN_STAGING: vault-staging.freijstack.com
  BACKEND_DOMAIN_STAGING: vault-api-staging.freijstack.com

jobs:
  validate:
    name: ‚úÖ Validate VPS Configuration
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master')) || 
      github.event_name == 'workflow_dispatch'

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: üîí Mask sensitive values
        run: |
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}"
          echo "::add-mask::${{ secrets.VPS_SSH_HOST }}"
          # Mask combined user@host too
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"

      - name: üåê Check DNS Configuration
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üîç Checking DNS records for $TARGET_ENV..."
          
          # Fonction pour v√©rifier un DNS
          check_dns() {
            DOMAIN=$1
            echo "Checking $DOMAIN..."
            if dig +short $DOMAIN | grep -q '[0-9]'; then
              IP=$(dig +short $DOMAIN | head -n1)
              echo "‚úÖ $DOMAIN ‚Üí $IP"
              return 0
            else
              echo "‚ùå $DOMAIN not configured"
              return 1
            fi
          }
          
          FAILED=0
          
          if [ "$TARGET_ENV" = "production" ]; then
            check_dns "${{ env.FRONTEND_DOMAIN_PROD }}" || FAILED=1
            check_dns "${{ env.BACKEND_DOMAIN_PROD }}" || FAILED=1
          else
            check_dns "${{ env.FRONTEND_DOMAIN_STAGING }}" || FAILED=1
            check_dns "${{ env.BACKEND_DOMAIN_STAGING }}" || FAILED=1
          fi
          
          if [ $FAILED -eq 1 ]; then
            echo ""
            echo "‚ö†Ô∏è Some DNS records are missing. Please configure them:"
            echo "   - Add A records pointing to your VPS IP"
            echo "   - Wait 5-10 minutes for propagation"
            exit 1
          fi
          
          echo "‚úÖ All DNS records configured correctly"

      - name: üîç Check VPS Prerequisites
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          # D√©terminer les chemins selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            VPS_ENV_FILE="${{ env.VPS_ENV_FILE_PROD }}"
          else
            VPS_ENV_FILE="${{ env.VPS_ENV_FILE_STAGING }}"
          fi
          
          # Passer les variables au script SSH via export
          export TARGET_ENV VPS_ENV_FILE
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} "TARGET_ENV='$TARGET_ENV' VPS_ENV_FILE='$VPS_ENV_FILE'" bash << 'VPS_CHECK'
            echo "üîç Checking VPS configuration..."
            echo "Environment: $TARGET_ENV"
            echo "ENV File: $VPS_ENV_FILE"
            echo ""

            # Mask sensitive values from existing .env if present
            echo "üîí Applying runtime masks for sensitive values..."
            if [ -f "$VPS_ENV_FILE" ]; then
              for VAR in DB_PASSWORD JWT_SECRET ENCRYPTION_KEY POSTGRES_PASSWORD; do
                VALUE=$(grep -E "^${VAR}=" "$VPS_ENV_FILE" 2>/dev/null | cut -d'=' -f2- || echo "")
                if [ -n "$VALUE" ]; then
                  echo "::add-mask::$VALUE"
                  echo "  ‚úÖ Masked $VAR"
                fi
              done
            fi
            
            # 1. V√©rifier Docker
            echo "1Ô∏è‚É£ Checking Docker..."
            if command -v docker &> /dev/null; then
              DOCKER_VERSION=$(docker --version)
              echo "‚úÖ Docker installed: $DOCKER_VERSION"
            else
              echo "‚ùå Docker not installed"
              exit 1
            fi
            
            # 2. V√©rifier Docker Compose
            echo ""
            echo "2Ô∏è‚É£ Checking Docker Compose..."
            if docker compose version &> /dev/null; then
              COMPOSE_VERSION=$(docker compose version)
              echo "‚úÖ Docker Compose installed: $COMPOSE_VERSION"
            else
              echo "‚ùå Docker Compose not installed"
              exit 1
            fi
            
            # 3. V√©rifier le r√©seau web
            echo ""
            echo "3Ô∏è‚É£ Checking Docker network 'web'..."
            if docker network ls | grep -q "web"; then
              echo "‚úÖ Network 'web' exists"
            else
              echo "‚ö†Ô∏è Network 'web' not found, creating it..."
              docker network create web
              echo "‚úÖ Network 'web' created successfully"
            fi
            
            # 4. V√©rifier Traefik
            echo ""
            echo "4Ô∏è‚É£ Checking Traefik..."
            TRAEFIK_CONTAINER=$(docker ps --format '{{.Names}}' | grep -i 'traefik' | head -n1)
            if [ -n "$TRAEFIK_CONTAINER" ]; then
              TRAEFIK_STATUS=$(docker ps --filter "name=$TRAEFIK_CONTAINER" --format "{{.Status}}")
              echo "‚úÖ Traefik is running: $TRAEFIK_STATUS (container: $TRAEFIK_CONTAINER)"
            else
              echo "‚ö†Ô∏è Traefik not running (containers will be accessible without reverse proxy)"
              echo "   For HTTPS/TLS and proper routing, deploy base infrastructure:"
              echo "   cd /srv/docker/freijstack/base-infra && docker compose up -d"
              echo ""
              echo "‚ÑπÔ∏è  Continuing deployment without Traefik..."
            fi
            
            # 5. V√©rifier le fichier .env
            echo ""
            echo "5Ô∏è‚É£ Checking .env file..."
            if [ -f "$VPS_ENV_FILE" ]; then
              echo "‚úÖ .env file exists at $VPS_ENV_FILE"
              
              # D√©terminer les domaines selon l'environnement
              if [ "$TARGET_ENV" = "production" ]; then
                API_DOM="vault-api.freijstack.com"
                FRONTEND_DOM="vault.freijstack.com"
                FRONTEND_U="https://vault.freijstack.com"
                PROJECT_NAME="securevault"
              else
                API_DOM="vault-api-staging.freijstack.com"
                FRONTEND_DOM="vault-staging.freijstack.com"
                FRONTEND_U="https://vault-staging.freijstack.com"
                PROJECT_NAME="securevault-staging"
              fi
              
              # V√©rifier et ajouter les variables manquantes
              UPDATED=0
              
              if ! grep -q "^COMPOSE_PROJECT_NAME=" "$VPS_ENV_FILE"; then
                echo "" >> "$VPS_ENV_FILE"
                echo "COMPOSE_PROJECT_NAME=$PROJECT_NAME" >> "$VPS_ENV_FILE"
                echo "‚ö†Ô∏è Added missing COMPOSE_PROJECT_NAME=$PROJECT_NAME"
                UPDATED=1
              fi
              
              if ! grep -q "^API_DOMAIN=" "$VPS_ENV_FILE"; then
                echo "API_DOMAIN=$API_DOM" >> "$VPS_ENV_FILE"
                echo "‚ö†Ô∏è Added missing API_DOMAIN=$API_DOM"
                UPDATED=1
              fi
              
              if ! grep -q "^FRONTEND_DOMAIN=" "$VPS_ENV_FILE"; then
                echo "FRONTEND_DOMAIN=$FRONTEND_DOM" >> "$VPS_ENV_FILE"
                echo "‚ö†Ô∏è Added missing FRONTEND_DOMAIN=$FRONTEND_DOM"
                UPDATED=1
              fi
              
              if ! grep -q "^FRONTEND_URL=" "$VPS_ENV_FILE"; then
                echo "FRONTEND_URL=$FRONTEND_U" >> "$VPS_ENV_FILE"
                echo "‚ö†Ô∏è Added missing FRONTEND_URL=$FRONTEND_U"
                UPDATED=1
              fi
              
              # V√©rifier les secrets critiques
              MISSING_SECRETS=""
              for VAR in DB_PASSWORD JWT_SECRET ENCRYPTION_KEY; do
                if ! grep -q "^${VAR}=" "$VPS_ENV_FILE" 2>/dev/null; then
                  MISSING_SECRETS="$MISSING_SECRETS $VAR"
                  echo "  ‚ö†Ô∏è  Missing: $VAR"
                else
                  echo "  ‚úÖ Found: $VAR"
                fi
              done
              
              if [ -n "$MISSING_SECRETS" ]; then
                echo ""
                echo "‚ùå Missing critical secrets:$MISSING_SECRETS"
                echo "   Add them to $VPS_ENV_FILE:"
                echo "   DB_PASSWORD=\$(openssl rand -hex 32)"
                echo "   JWT_SECRET=\$(openssl rand -hex 32)"
                echo "   ENCRYPTION_KEY=\$(openssl rand -hex 32)"
                exit 1
              fi
              
              if [ $UPDATED -eq 1 ]; then
                echo "‚úÖ .env file updated with missing domain variables"
              else
                echo "‚úÖ All required variables present"
              fi
            else
              echo "‚ö†Ô∏è .env file not found, creating it with generated secrets..."
              
              # Cr√©er le r√©pertoire si n√©cessaire
              mkdir -p $(dirname "$VPS_ENV_FILE")
              
              # G√©n√©rer les secrets
              DB_PASS=$(openssl rand -hex 32)
              JWT_SEC=$(openssl rand -hex 32)
              ENC_KEY=$(openssl rand -hex 32)
              
              # D√©terminer les domaines selon l'environnement
              if [ "$TARGET_ENV" = "production" ]; then
                API_DOM="vault-api.freijstack.com"
                FRONTEND_DOM="vault.freijstack.com"
                FRONTEND_U="https://vault.freijstack.com"
                PROJECT_NAME="securevault"
              else
                API_DOM="vault-api-staging.freijstack.com"
                FRONTEND_DOM="vault-staging.freijstack.com"
                FRONTEND_U="https://vault-staging.freijstack.com"
                PROJECT_NAME="securevault-staging"
              fi
              
              # Cr√©er le fichier .env avec les secrets g√©n√©r√©s
              {
                echo "# Auto-generated secrets for SecureVault $TARGET_ENV"
                echo "# Generated on $(date)"
                echo ""
                echo "COMPOSE_PROJECT_NAME=$PROJECT_NAME"
                echo ""
                echo "DB_PASSWORD=$DB_PASS"
                echo "JWT_SECRET=$JWT_SEC"
                echo "ENCRYPTION_KEY=$ENC_KEY"
                echo ""
                echo "# Domain configuration"
                echo "API_DOMAIN=$API_DOM"
                echo "FRONTEND_DOMAIN=$FRONTEND_DOM"
                echo "FRONTEND_URL=$FRONTEND_U"
              } > "$VPS_ENV_FILE"
              
              chmod 600 "$VPS_ENV_FILE"
              echo "‚úÖ .env file created at $VPS_ENV_FILE with secure permissions"
            fi
            
            # 6. V√©rifier les permissions
            echo ""
            echo "6Ô∏è‚É£ Checking .env permissions..."
            PERMS=$(stat -c %a "$VPS_ENV_FILE" 2>/dev/null || stat -f %A "$VPS_ENV_FILE")
            if [ "$PERMS" = "600" ]; then
              echo "‚úÖ .env permissions are secure (600)"
            else
              echo "‚ö†Ô∏è .env permissions are $PERMS (should be 600)"
              echo "   Fix with: chmod 600 $VPS_ENV_FILE"
            fi
            
            echo ""
            echo "‚úÖ All VPS prerequisites validated for $TARGET_ENV!"
          VPS_CHECK

      - name: ‚úÖ Validation Summary
        if: success()
        run: |
          echo "‚úÖ VPS Configuration Validated Successfully!"
          echo ""
          echo "Environment: ${{ github.ref == 'refs/heads/master' && 'Production' || 'Staging' }}"
          echo "Ready for deployment üöÄ"

      - name: ‚ùå Validation Failed
        if: failure()
        run: |
          echo "‚ùå VPS Configuration Validation Failed"
          echo ""
          echo "Please fix the issues above before deploying."
          echo "Review the logs for specific error messages."
          exit 1

  test:
    name: üß™ Test & Build
    runs-on: ubuntu-latest
    needs: validate
    permissions:
      contents: read
      security-events: write

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Set up Node.js (Backend)
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: 'saas/securevault/backend/package.json'

      - name: üß™ Test Backend
        working-directory: saas/securevault/backend
        run: |
          npm install
          npm test -- --passWithNoTests || true
        continue-on-error: true

      - name: Lint Backend
        working-directory: saas/securevault/backend
        run: npm run lint --if-present
        continue-on-error: true

      - name: üîß Set up Node.js (Frontend)
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: 'saas/securevault/frontend/package.json'

      - name: üß™ Test Frontend
        working-directory: saas/securevault/frontend
        run: |
          npm install
          npm test -- --passWithNoTests || true
        continue-on-error: true

      - name: üê≥ Build Docker images
        working-directory: saas/securevault
        run: |
          docker build -t securevault-backend:test ./backend
          docker build -t securevault-frontend:test ./frontend

      - name: üîç Run Trivy vulnerability scan (Backend)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'securevault-backend:test'
          format: 'sarif'
          output: 'trivy-backend.sarif'
        continue-on-error: true

      - name: üîç Run Trivy vulnerability scan (Frontend)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'securevault-frontend:test'
          format: 'sarif'
          output: 'trivy-frontend.sarif'
        continue-on-error: true

      - name: Upload Trivy results to GitHub Security (Backend)
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-backend.sarif'
          category: 'securevault-backend'
        continue-on-error: true

      - name: Upload Trivy results to GitHub Security (Frontend)
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-frontend.sarif'
          category: 'securevault-frontend'
        continue-on-error: true

  cleanup:
    name: üßπ Cleanup Old Containers
    runs-on: ubuntu-latest
    needs: test
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master')) || 
      github.event_name == 'workflow_dispatch'

    steps:
      - name: üîê Prepare SSH key
        run: |
          set -e -x
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          sleep 2
          ssh-keyscan -H ${{ secrets.VPS_SSH_HOST }} >> ~/.ssh/known_hosts
          ls -l ~/.ssh
          # V√©rification permissions et format (ne pas afficher la cl√© en clair)
          if [ $(stat -c %a ~/.ssh/deploy_key) != "600" ]; then
            echo "‚ùå Permissions incorrectes sur deploy_key"; exit 1; fi
          head -n 2 ~/.ssh/deploy_key

      - name: üîí Mask sensitive values
        run: |
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}"
          echo "::add-mask::${{ secrets.VPS_SSH_HOST }}"
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"

      - name: üßπ Force remove old containers
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üéØ Cleanup for environment: $TARGET_ENV"
          
          # D√©terminer les conteneurs et r√©seaux selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            CONTAINERS="${{ env.CONTAINER_PREFIX_PROD }}-backend ${{ env.CONTAINER_PREFIX_PROD }}-frontend ${{ env.CONTAINER_PREFIX_PROD }}-postgres"
            NETWORKS="${{ env.NETWORK_PROD }}"
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_PROD }}"
            PROJECT_PATH="${{ env.PROJECT_PATH }}"
          else
            CONTAINERS="${{ env.CONTAINER_PREFIX_STAGING }}-backend ${{ env.CONTAINER_PREFIX_STAGING }}-frontend ${{ env.CONTAINER_PREFIX_STAGING }}-postgres"
            NETWORKS="${{ env.NETWORK_STAGING }}"
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_STAGING }}"
            PROJECT_PATH="${{ env.PROJECT_PATH }}"
          fi
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} "TARGET_ENV='$TARGET_ENV' CONTAINERS='$CONTAINERS' NETWORKS='$NETWORKS' DEPLOY_DIR='$DEPLOY_DIR' PROJECT_PATH='$PROJECT_PATH'" bash << 'CLEANUP_SCRIPT'
            set -e
            echo "üßπ Cleaning up old containers and networks..."
            echo "Environment: $TARGET_ENV"
            echo "Deploy directory: $DEPLOY_DIR"
            echo "Containers to remove: $CONTAINERS"
            echo "Networks to remove: $NETWORKS"
            
            # Arr√™ter les conteneurs via docker compose si le dossier existe
            if [ -d "$DEPLOY_DIR/$PROJECT_PATH" ]; then
              echo "üìÇ Found existing deployment, stopping services..."
              cd "$DEPLOY_DIR/$PROJECT_PATH"
              docker compose down 2>/dev/null || echo "  ‚ÑπÔ∏è  No compose services running"
            fi
            
            # Arr√™ter et supprimer les conteneurs s'ils existent
            for CONTAINER in $CONTAINERS; do
              if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER}$"; then
                echo "Removing container: $CONTAINER"
                docker rm -f "$CONTAINER" || true
              else
                echo "Container $CONTAINER does not exist, skipping"
              fi
            done
            
            # Supprimer les r√©seaux avec leurs labels incorrects
            for NETWORK in $NETWORKS; do
              if docker network ls --format '{{.Name}}' | grep -q "^${NETWORK}$"; then
                echo "üîß Removing network with incorrect labels: $NETWORK"
                docker network rm "$NETWORK" 2>/dev/null || echo "  ‚ö†Ô∏è  Could not remove $NETWORK (may have active endpoints)"
              else
                echo "Network $NETWORK does not exist, skipping"
              fi
            done
            
            echo "‚úÖ Cleanup complete (volumes preserved for data safety)"
            echo "   Networks will be recreated with correct labels during deployment"
          CLEANUP_SCRIPT

  deploy:
    name: üöÄ Deploy to VPS
    runs-on: ubuntu-latest
    needs: cleanup
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master')) || 
      github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ github.ref == 'refs/heads/master' && 'production' || 'staging' }}
      url: ${{ github.ref == 'refs/heads/master' && 'https://vault.freijstack.com' || 'https://vault-staging.freijstack.com' }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: üîí Mask sensitive values
        run: |
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}"
          echo "::add-mask::${{ secrets.VPS_SSH_HOST }}"
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"

      - name: üöÄ Deploy to VPS
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üéØ Target environment: $TARGET_ENV"
          
          # D√©terminer les chemins selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_PROD }}"
            VPS_ENV_FILE="${{ env.VPS_ENV_FILE_PROD }}"
            BRANCH="${{ env.BRANCH_PROD }}"
            ENV_TEMPLATE=".env.production"
          else
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_STAGING }}"
            VPS_ENV_FILE="${{ env.VPS_ENV_FILE_STAGING }}"
            BRANCH="${{ env.BRANCH_STAGING }}"
            ENV_TEMPLATE=".env.staging"
          fi
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} "TARGET_ENV='$TARGET_ENV' DEPLOY_DIR='$DEPLOY_DIR' VPS_ENV_FILE='$VPS_ENV_FILE' BRANCH='$BRANCH' ENV_TEMPLATE='$ENV_TEMPLATE' PROJECT_PATH='${{ env.PROJECT_PATH }}' GITHUB_REPO='${{ github.repository }}'" bash << 'DEPLOY_SCRIPT'
            set -e
            echo "üöÄ Starting SecureVault deployment..."
            echo "üéØ Deploying to: $TARGET_ENV"
            echo "üìÇ Deploy directory: $DEPLOY_DIR"
            echo "üìù VPS ENV file: $VPS_ENV_FILE"
            
            # Cloner/mettre √† jour le repo
            if [ -d "$DEPLOY_DIR/.git" ]; then
              echo "‚úÖ Repository already exists, pulling latest changes..."
              cd "$DEPLOY_DIR"
              git fetch origin
              git reset --hard origin/$BRANCH
              git clean -fd
            else
              echo "üì• Cloning repository for the first time..."
              # Supprimer le r√©pertoire s'il existe mais n'est pas un repo Git
              if [ -d "$DEPLOY_DIR" ]; then
                echo "üßπ Cleaning existing directory..."
                rm -rf "$DEPLOY_DIR"
              fi
              git clone -b $BRANCH https://github.com/$GITHUB_REPO.git "$DEPLOY_DIR"
              cd "$DEPLOY_DIR"
            fi
            
            # Naviguer vers securevault
            cd $PROJECT_PATH
            
            echo "üìù Using environment template: $ENV_TEMPLATE"
            
            # V√©rifier que le template existe dans le repo
            if [ ! -f "$ENV_TEMPLATE" ]; then
              echo "‚ùå ERREUR: Template $ENV_TEMPLATE manquant dans le repo"
              exit 1
            fi
            
            # Copier le template comme base
            cp "$ENV_TEMPLATE" .env
            
            # V√©rifier et injecter les secrets depuis le fichier .env du VPS
            if [ -f "$VPS_ENV_FILE" ]; then
              echo "üîê Injecting secrets from VPS .env file..."
              
              # Extraire les secrets critiques du fichier VPS
              for SECRET_VAR in POSTGRES_PASSWORD JWT_SECRET ENCRYPTION_KEY; do
                SECRET_VALUE=$(grep -E "^${SECRET_VAR}=" "$VPS_ENV_FILE" 2>/dev/null | cut -d'=' -f2- || echo "")
                if [ -n "$SECRET_VALUE" ]; then
                  # Remplacer dans le fichier .env local
                  if grep -q "^${SECRET_VAR}=" .env; then
                    sed -i "s|^${SECRET_VAR}=.*|${SECRET_VAR}=${SECRET_VALUE}|" .env
                  else
                    echo "${SECRET_VAR}=${SECRET_VALUE}" >> .env
                  fi
                  echo "  ‚úÖ Injected ${SECRET_VAR}"
                else
                  echo "  ‚ö†Ô∏è ${SECRET_VAR} not found in VPS .env, using template default"
                fi
              done
            else
              echo "‚ö†Ô∏è VPS .env file not found at $VPS_ENV_FILE"
              echo "   Using template defaults (INSECURE for production!)"
            fi
            
            echo "üîß Building and starting containers..."
            docker compose pull
            docker compose up -d --build --remove-orphans
            
            # Attendre que les services soient pr√™ts
            sleep 10
            
            # V√©rifier la sant√©
            echo "üè• Checking health..."
            docker compose ps
            
            echo "‚úÖ Deployment successful!"
            echo "üìä Logs:"
            docker compose logs --tail=20
          DEPLOY_SCRIPT

      - name: üóÑÔ∏è Run Database Migrations
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üóÑÔ∏è Running database migrations for $TARGET_ENV..."
          
          # D√©terminer le r√©pertoire selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_PROD }}"
            PROJECT_PATH="${{ env.PROJECT_PATH }}"
            CONTAINER_PREFIX="${{ env.CONTAINER_PREFIX_PROD }}"
          else
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_STAGING }}"
            PROJECT_PATH="${{ env.PROJECT_PATH }}"
            CONTAINER_PREFIX="${{ env.CONTAINER_PREFIX_STAGING }}"
          fi
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} "DEPLOY_DIR='$DEPLOY_DIR' PROJECT_PATH='$PROJECT_PATH' CONTAINER_PREFIX='$CONTAINER_PREFIX'" bash << 'MIGRATION_SCRIPT'
            set -e
            cd "$DEPLOY_DIR/$PROJECT_PATH"
            
            echo "üìÇ Current directory: $(pwd)"
            echo "üê≥ PostgreSQL container: ${CONTAINER_PREFIX}-postgres"
            
            # Auto-detect PostgreSQL user and database from .env
            echo ""
            echo "üîç Detecting PostgreSQL credentials from .env..."
            if [ -f ".env" ]; then
              PGUSER=$(grep "^POSTGRES_USER=" .env | cut -d'=' -f2 | tr -d '\r' || echo "postgres")
              PGDATABASE=$(grep "^POSTGRES_DB=" .env | cut -d'=' -f2 | tr -d '\r' || echo "securevault")
              
              echo "  ‚úì PostgreSQL User: $PGUSER"
              echo "  ‚úì Database: $PGDATABASE"
            else
              echo "  ‚ö†Ô∏è  .env not found, using defaults"
              PGUSER="postgres"
              PGDATABASE="securevault"
            fi
            
            # Attendre que PostgreSQL soit pr√™t
            echo ""
            echo "‚è≥ Waiting for PostgreSQL to be ready..."
            for i in {1..30}; do
              if docker compose exec -T postgres pg_isready -U "$PGUSER" &> /dev/null; then
                echo "‚úÖ PostgreSQL is ready!"
                break
              fi
              echo "  ‚è≥ Attempt $i/30..."
              sleep 2
            done
            
            # Test de connexion
            echo ""
            echo "üîå Testing database connection..."
            if docker compose exec -T postgres psql -U "$PGUSER" -d "$PGDATABASE" -c "SELECT version();" &> /dev/null; then
              echo "‚úÖ Database connection successful"
            else
              echo "‚ùå Cannot connect to database"
              echo "   Trying to list available databases..."
              docker compose exec -T postgres psql -U "$PGUSER" -l 2>&1 || echo "   Connection failed"
              exit 1
            fi
            
            # V√©rifier que les fichiers de migration existent
            echo ""
            echo "üìã Available migration files:"
            ls -lh backend/migrations/ || echo "‚ö†Ô∏è No migrations directory found"
            
            # Fonction pour ex√©cuter une migration
            run_migration() {
              local migration_file=$1
              local migration_num=$2
              local check_table=$3
              
              echo ""
              echo "${migration_num} Checking ${migration_file}..."
              
              if [ ! -f "backend/migrations/${migration_file}" ]; then
                echo "  ‚ö†Ô∏è Migration file not found, skipping"
                return
              fi
              
              # V√©rifier si d√©j√† appliqu√©e via table indicatrice
              if docker compose exec -T postgres psql -U "$PGUSER" -d "$PGDATABASE" -tAc \
                "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = '$check_table');" 2>/dev/null | grep -q "t"; then
                echo "  ‚ÑπÔ∏è  Migration already applied ($check_table table exists)"
              else
                echo "  ‚ñ∂Ô∏è  Applying ${migration_file}..."
                
                # Appliquer la migration
                if docker compose exec -T postgres psql -U "$PGUSER" -d "$PGDATABASE" < "backend/migrations/${migration_file}" 2>&1 | tee /tmp/migration.log; then
                  echo "  ‚úÖ Migration applied successfully"
                else
                  echo "  ‚ùå Migration failed! Check logs above"
                  cat /tmp/migration.log
                  return 1
                fi
              fi
            }
            
            # Ex√©cuter les migrations dans l'ordre
            run_migration "001_add_features.sql" "1Ô∏è‚É£" "roles"
            run_migration "002_pro_features.sql" "2Ô∏è‚É£" "folders"
            
            # Afficher un r√©sum√© des tables
            echo ""
            echo "üìä Database schema summary:"
            docker compose exec -T postgres psql -U "$PGUSER" -d "$PGDATABASE" -c "\dt" 2>&1 | head -30 || echo "  ‚ö†Ô∏è Could not list tables"
            
            # Compter quelques tables importantes
            echo ""
            echo "üìà Database statistics:"
            for table in users secrets roles folders secret_types; do
              COUNT=$(docker compose exec -T postgres psql -U "$PGUSER" -d "$PGDATABASE" -tAc \
                "SELECT COUNT(*) FROM $table;" 2>/dev/null | tr -d ' \r\n' || echo "N/A")
              if [ "$COUNT" != "N/A" ]; then
                echo "  ‚Ä¢ $table: $COUNT rows"
              fi
            done
            
            echo ""
            echo "‚úÖ Database migrations completed!"
          MIGRATION_SCRIPT

      - name: üèóÔ∏è Initialize Database Schema
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üèóÔ∏è Running init-db.sh for $TARGET_ENV..."
          if [ "$TARGET_ENV" = "production" ]; then
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_PROD }}"
            PROJECT_PATH="${{ env.PROJECT_PATH }}"
          else
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_STAGING }}"
            PROJECT_PATH="${{ env.PROJECT_PATH }}"
          fi
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} "cd $DEPLOY_DIR/$PROJECT_PATH && chmod +x ./init-db.sh && ./init-db.sh $TARGET_ENV"

      - name: üîÑ Restart Traefik
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üîÑ Restarting Traefik as requested..."
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} << 'TRAEFIK_RESTART'
            set -e
            TRAEFIK_CONTAINER=$(docker ps --format '{{.Names}}' | grep -i 'traefik' | head -n1)
            if [ -z "$TRAEFIK_CONTAINER" ]; then
              echo "‚ùå Traefik container not found"
              exit 1
            fi
            echo "Restarting $TRAEFIK_CONTAINER..."
            docker restart "$TRAEFIK_CONTAINER"
            sleep 5
            echo "‚úÖ Traefik restarted"
          TRAEFIK_RESTART

      - name: Verify Deployment
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "üîç V√©rification du d√©ploiement sur $TARGET_ENV..."
          sleep 5
          
          # D√©terminer le r√©pertoire selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_PROD }}"
          else
            DEPLOY_DIR="${{ env.VPS_DEPLOY_DIR_STAGING }}"
          fi
          
          # V√©rifier que les conteneurs tournent sur le VPS
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} "cd $DEPLOY_DIR/${{ env.PROJECT_PATH }} && docker compose ps"
          
          echo "‚úÖ D√©ploiement v√©rifi√© avec succ√®s!"

      - name: ‚úÖ Notify Deployment Success
        if: success()
        run: |
          echo "‚úÖ SecureVault deployment successful!"
          echo "Environment: ${{ github.ref == 'refs/heads/master' && 'production' || 'staging' }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"

      - name: ‚ùå Notify Deployment Failure
        if: failure()
        run: |
          echo "‚ùå SecureVault deployment failed!"
          echo "Check logs above for details"
          exit 1

  post-verify:
    name: üîé Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: üîí Mask sensitive values
        run: |
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}"
          echo "::add-mask::${{ secrets.VPS_SSH_HOST }}"
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"

      - name: üîç Inspect Traefik for routers
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          echo "‚è≥ Waiting 15 seconds for containers to fully start..."
          sleep 15
          
          echo "üîç Checking Traefik routers in logs..."
          
          # D√©terminer les domaines selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            FRONTEND_DOM="${{ env.FRONTEND_DOMAIN_PROD }}"
            API_DOM="${{ env.BACKEND_DOMAIN_PROD }}"
          else
            FRONTEND_DOM="${{ env.FRONTEND_DOMAIN_STAGING }}"
            API_DOM="${{ env.BACKEND_DOMAIN_STAGING }}"
          fi

          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} << 'VERIFY_LOGS'
            TRAEFIK_CONTAINER=$(docker ps --format '{{.Names}}' | grep -i 'traefik' | head -n1)
            if [ -z "$TRAEFIK_CONTAINER" ]; then
              echo "‚ö†Ô∏è  Traefik not running (containers accessible without reverse proxy)"
              echo "‚ÑπÔ∏è  To enable HTTPS/TLS and routing, deploy base infrastructure:"
              echo "    cd /srv/docker/freijstack/base-infra && docker compose up -d"
            else
              echo "‚úÖ Found Traefik container: $TRAEFIK_CONTAINER"
              echo "üìú Last Traefik logs (filtered):"
              docker logs --tail=50 "$TRAEFIK_CONTAINER" | grep -E "(vault|mytlschallenge|websecure|entryPoints)" || echo "No matching logs"
              echo "‚úÖ Log inspection done"
            fi
          VERIFY_LOGS

      - name: üåê HTTP checks (TLS & routes)
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'staging') }}
        run: |
          # D√©terminer les domaines selon l'environnement
          if [ "$TARGET_ENV" = "production" ]; then
            FRONTEND_DOM="${{ env.FRONTEND_DOMAIN_PROD }}"
            API_DOM="${{ env.BACKEND_DOMAIN_PROD }}"
          else
            FRONTEND_DOM="${{ env.FRONTEND_DOMAIN_STAGING }}"
            API_DOM="${{ env.BACKEND_DOMAIN_STAGING }}"
          fi

          check_url() {
            DOMAIN="$1"
            ATTEMPTS=3
            DELAY=10
            for i in $(seq 1 $ATTEMPTS); do
              # Accept self-signed certs temporarily with -k
              CODE=$(curl -sSLk -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 20 "https://$DOMAIN" || echo "000")
              echo "Attempt $i: $DOMAIN ‚Üí HTTP $CODE"
              case "$CODE" in
                200|301|302|404)
                  echo "‚úÖ $DOMAIN reachable (HTTP $CODE)"
                  return 0
                  ;;
                *)
                  sleep "$DELAY"
                  ;;
              esac
            done
            echo "‚ö†Ô∏è $DOMAIN not reachable with valid status after retries (last: $CODE)"
            return 1
          }

          FAILED=0
          check_url "$FRONTEND_DOM" || FAILED=1
          check_url "$API_DOM" || FAILED=1

          if [ $FAILED -eq 1 ]; then
            echo "‚ùå Post-deployment verification failed"
            exit 1
          fi
  destroy-staging:
    name: üî• Destroy Staging After Merge
    runs-on: ubuntu-latest
    needs: [deploy, post-verify]
    # D√©truire staging uniquement si :
    # 1. Push vers master (merge depuis develop) OU
    # 2. Manuel avec flag destroy_staging=true
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/master') ||
      (github.event_name == 'workflow_dispatch' && inputs.destroy_staging == true)
    
    steps:
      - name: üîê Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_SSH_HOST }} >> ~/.ssh/known_hosts
      
      - name: üîí Mask sensitive values
        run: |
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}"
          echo "::add-mask::${{ secrets.VPS_SSH_HOST }}"
          echo "::add-mask::${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"
      
      - name: üî• Destroy Staging Environment
        run: |
          echo "üî• Destroying staging environment..."
          echo "‚ö†Ô∏è  This will stop and remove all staging containers"
          echo ""
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }} << 'DESTROY_SCRIPT'
            set -e
            
            STAGING_DIR="/srv/www/securevault-staging"
            
            echo "üéØ Target: Staging environment"
            echo "üìÇ Directory: $STAGING_DIR"
            echo ""
            
            if [ -d "$STAGING_DIR/saas/securevault" ]; then
              cd "$STAGING_DIR/saas/securevault"
              
              echo "üõë Stopping all staging containers..."
              docker compose down 2>/dev/null || echo "  ‚ÑπÔ∏è  No containers running"
              
              echo "üóëÔ∏è  Removing staging containers..."
              for container in securevault-staging-backend securevault-staging-frontend securevault-staging-postgres; do
                if docker ps -a --format '{{.Names}}' | grep -q "^${container}$"; then
                  echo "  ‚Ä¢ Removing $container"
                  docker rm -f "$container" 2>/dev/null || true
                fi
              done
              
              echo "üîå Removing staging network..."
              docker network rm securevault_staging_network 2>/dev/null || echo "  ‚ÑπÔ∏è  Network already removed"
              
              echo "üíæ Preserving volumes (data safety)..."
              echo "  ‚ÑπÔ∏è  Volumes kept for potential recovery"
              echo "  ‚ÑπÔ∏è  To remove volumes manually: docker volume rm securevault-staging_postgres_data"
              
              echo ""
              echo "‚úÖ Staging environment destroyed successfully!"
              echo ""
              echo "üìä Remaining staging resources:"
              echo ""
              echo "Volumes (preserved):"
              docker volume ls | grep staging || echo "  None"
              echo ""
              echo "To completely remove staging including data:"
              echo "  docker volume rm \$(docker volume ls -q | grep staging)"
            else
              echo "‚ö†Ô∏è  Staging directory not found, nothing to destroy"
            fi
          DESTROY_SCRIPT
      
      - name: ‚úÖ Staging Destroyed
        if: success()
        run: |
          echo "‚úÖ Staging environment destroyed"
          echo ""
          echo "üéØ Production is now the only active environment"
          echo "üìç https://vault.freijstack.com"
          echo ""
          echo "‚ÑπÔ∏è  To recreate staging:"
          echo "   1. Push to develop branch"
          echo "   2. Workflow will automatically deploy staging"
      
      - name: ‚ùå Destruction Failed
        if: failure()
        run: |
          echo "‚ùå Failed to destroy staging environment"
          echo "Manual cleanup may be required"

  notify:
    name: üì¢ Notify Status
    runs-on: ubuntu-latest
    needs: [validate, test, deploy, post-verify, destroy-staging]
    if: always()
    
    steps:
      - name: Check overall status
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "üîç Pull Request - Validation Only"
            echo "‚úÖ Code validation and security checks completed"
            echo "üìã No deployment on pull requests"
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            echo "üß™ STAGING Environment - Push Event"
            echo "‚úÖ SecureVault staging deployment completed"
            echo "üìç https://vault-staging.freijstack.com"
            echo "üìç API: https://vault-api-staging.freijstack.com"
            echo ""
            echo "‚ÑπÔ∏è  This environment is temporary and will be destroyed on merge to master"
          elif [ "${{ github.ref }}" == "refs/heads/master" ]; then
            echo "üöÄ PRODUCTION Environment - Merge Complete"
            echo "‚úÖ SecureVault production deployment completed"
            echo "üéØ https://vault.freijstack.com"
            echo "üéØ API: https://vault-api.freijstack.com"
            echo ""
            if [ "${{ needs.destroy-staging.result }}" == "success" ]; then
              echo "üî• Staging environment destroyed automatically"
              echo "‚úÖ Production is now the only active environment"
            fi
          else
            echo "‚ÑπÔ∏è Event: ${{ github.event_name }} on ${{ github.ref }}"
          fi

      - name: ‚úÖ Success Summary
        if: ${{ needs.validate.result == 'success' && needs.test.result == 'success' && needs.deploy.result == 'success' && needs.post-verify.result == 'success' }}
        run: |
          echo "‚úÖ All jobs completed successfully!"
          echo "üìä Validation: ‚úÖ"
          echo "üß™ Tests: ‚úÖ"
          echo "üöÄ Deployment: ‚úÖ"
          echo "üîé Post-verification: ‚úÖ"
          
          if [ "${{ needs.destroy-staging.result }}" == "success" ]; then
            echo "üî• Staging cleanup: ‚úÖ"
          fi

      - name: ‚ö†Ô∏è Partial Success
        if: ${{ (needs.validate.result == 'failure' || needs.test.result == 'failure' || needs.deploy.result == 'failure' || needs.post-verify.result == 'failure') }}
        run: |
          echo "‚ö†Ô∏è Some jobs failed:"
          echo "Validation: ${{ needs.validate.result }}"
          echo "Tests: ${{ needs.test.result }}"
          echo "Deploy: ${{ needs.deploy.result }}"
          echo "Post-verify: ${{ needs.post-verify.result }}"
          echo "Destroy-staging: ${{ needs.destroy-staging.result }}"

name: üß™ Health Check ‚Ä¢ Production

on:
  workflow_dispatch:
    inputs:
      auto_heal:
        description: "üîß Red√©marrer automatiquement si probl√®me d√©tect√©"
        required: false
        default: true
        type: boolean

  schedule:
    - cron: "*/30 * * * *"

concurrency:
  group: production-health-check
  cancel-in-progress: true

permissions:
  contents: read
  actions: read

jobs:
  health-check:
    name: üß™ Check Production Health
    runs-on: ubuntu-latest
    timeout-minutes: 6

    outputs:
      backend_status: ${{ steps.backend.outputs.status }}
      db_status: ${{ steps.database.outputs.status }}
      leaks_count: ${{ steps.gitleaks.outputs.leaks_count }}

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------------------------
      # üîê SECURITY ‚Äî Secret Scan (PROD = blocking)
      # ---------------------------
      - name: üîê Secret scanning (Gitleaks CLI)
        id: gitleaks
        run: |
          set -euo pipefail

          echo "‚¨áÔ∏è Installing gitleaks (pinned version)..."
          GITLEAKS_VERSION="8.21.2"
          curl -sSL "https://github.com/gitleaks/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz" \
            | tar -xz gitleaks
          sudo mv gitleaks /usr/local/bin/gitleaks

          echo "üîé Running gitleaks (redacted)..."
          # On ne stoppe pas tout de suite pour pouvoir produire le report
          gitleaks detect \
            --source . \
            --config .gitleaks.toml \
            --redact \
            --report-format json \
            --report-path gitleaks-report.json \
            --verbose || true

          # Garantit un JSON valide m√™me si gitleaks n'a rien √©crit
          test -f gitleaks-report.json || echo "[]" > gitleaks-report.json

          leaks_count="$(jq 'length' gitleaks-report.json)"
          echo "leaks_count=${leaks_count}" >> "$GITHUB_OUTPUT"
          echo "üî¢ leaks_count=${leaks_count}"

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "## üîê Gitleaks (secrets scan)" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Total findings:** $leaks_count" >> "$GITHUB_STEP_SUMMARY"

          if [ "$leaks_count" != "0" ]; then
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "### üîé Top 20 findings (metadata only)" >> "$GITHUB_STEP_SUMMARY"
            jq -r '.[] | "- rule=\(.RuleID) file=\(.File):\(.StartLine) commit=\(.Commit|tostring|.[0:8])"' gitleaks-report.json \
              | head -n 20 >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "> ‚ÑπÔ∏è Values are redacted. See artifact for full metadata." >> "$GITHUB_STEP_SUMMARY"
          else
            echo "- ‚úÖ No findings detected." >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: üìé Upload gitleaks report (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: gitleaks-report.json
          retention-days: 7
          if-no-files-found: error

      - name: üõë Fail pipeline if secrets found (PROD gate)
        if: ${{ steps.gitleaks.outputs.leaks_count != '0' }}
        run: |
          echo "üö® Secrets detected by Gitleaks. Blocking PROD healthcheck."
          exit 1

      - name: üß∞ Prepare tools
        run: |
          set -euo pipefail
          echo "üß∞ Tools versions"
          curl --version | head -n 1

      # ---------------------------
      # üåê AVAILABILITY ‚Äî Frontend URLs with retries + sleep
      # ---------------------------
      - name: üåê Public URLs Health Check (strong anti false-positives)
        run: |
          set -euo pipefail

          echo "## üåê Public URLs Health Check" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Warm-up: laisse le temps aux DNS/CDN/TLS de se stabiliser
          echo "‚è≥ Warm-up 15s..."
          sleep 15

          # Format: "url|allowed_codes|label"
          URLS=(
            "https://portfolio.freijstack.com/|200,301,302|Portfolio"
            "https://christophe-freijanes.github.io/freijstack/|200,301,302|GitHub Pages"
          )

          # Fast pass + Grace pass
          FAST_RETRY=3
          FAST_DELAY=3
          GRACE_RETRY=8
          GRACE_DELAY=8

          # Param√®tres curl communs (anti faux positifs)
          # -4 : √©vite les soucis IPv6 (souvent la cause du HTTP 000)
          # --retry-all-errors + --retry-max-time : meilleure r√©silience
          CURL_COMMON=(
            -4
            -sS
            -L
            -o /dev/null
            -w "%{http_code}"
            --connect-timeout 12
            --max-time 35
            --retry 3
            --retry-delay 2
            --retry-all-errors
            --retry-max-time 120
            --user-agent "freijstack-healthcheck/1.1"
          )

          check_url() {
            local url="$1"
            local allowed="$2"
            local label="$3"
            local attempts="$4"
            local delay="$5"

            echo ""
            echo "üîé Checking $label ‚Üí $url"
            echo "- **$label** ($url)" >> "$GITHUB_STEP_SUMMARY"

            # DNS debug
            host="$(echo "$url" | sed -E 's#https?://([^/]+).*#\1#')"
            if command -v dig >/dev/null 2>&1; then
              ips="$(dig +short "$host" | tr '\n' ' ' || true)"
              [ -n "${ips:-}" ] && echo "  üåê DNS: $ips" || echo "  üåê DNS: (no A/AAAA from runner)"
            fi

            for i in $(seq 1 "$attempts"); do
              echo "  ‚è≥ Attempt $i/$attempts..."

              # HEAD d'abord, fallback GET si HEAD pas support√© / renvoie 405/000
              code="$(curl -I "${CURL_COMMON[@]}" "$url" 2>/tmp/curl_err || echo "000")"

              if [ "$code" = "405" ] || [ "$code" = "000" ]; then
                code="$(curl "${CURL_COMMON[@]}" "$url" 2>/tmp/curl_err || echo "000")"
              fi

              if echo ",$allowed," | grep -q ",$code,"; then
                echo "  ‚úÖ OK (HTTP $code)"
                echo "  - ‚úÖ HTTP $code (attempt $i/$attempts)" >> "$GITHUB_STEP_SUMMARY"
                return 0
              fi

              err="$(tail -n 1 /tmp/curl_err 2>/dev/null || true)"
              echo "  ‚ö†Ô∏è  HTTP $code (attempt $i/$attempts) $err"

              # Si HTTP 000, on attend un peu plus (souvent DNS/TLS)
              if [ "$code" = "000" ]; then
                sleep $((delay + 3))
              elif [ "$i" -lt "$attempts" ]; then
                sleep "$delay"
              fi
            done

            echo "  ‚ùå FAILED after $attempts attempts"
            echo "  - ‚ùå Failed after $attempts attempts (last HTTP $code)" >> "$GITHUB_STEP_SUMMARY"
            return 1
          }

          failures=0

          echo "### ‚ö° Fast pass" >> "$GITHUB_STEP_SUMMARY"
          for entry in "${URLS[@]}"; do
            url="${entry%%|*}"
            rest="${entry#*|}"
            allowed="${rest%%|*}"
            label="${rest##*|}"

            if ! check_url "$url" "$allowed" "$label" "$FAST_RETRY" "$FAST_DELAY"; then
              failures=$((failures + 1))
            fi
          done

          if [ "$failures" -gt 0 ]; then
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "### üßØ Grace pass (final attempt)" >> "$GITHUB_STEP_SUMMARY"
            echo "- Retrying with stronger tolerance..." >> "$GITHUB_STEP_SUMMARY"

            failures=0
            for entry in "${URLS[@]}"; do
              url="${entry%%|*}"
              rest="${entry#*|}"
              allowed="${rest%%|*}"
              label="${rest##*|}"

              if ! check_url "$url" "$allowed" "$label" "$GRACE_RETRY" "$GRACE_DELAY"; then
                failures=$((failures + 1))
              fi
            done
          fi

          if [ "$failures" -gt 0 ]; then
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "üö® **Health check FAILED** (after grace pass)" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "‚úÖ **All URLs healthy**" >> "$GITHUB_STEP_SUMMARY"


      # ---------------------------
      # üß† API ‚Äî Backend Health
      # ---------------------------
      - name: üîé Check Backend SecureVault API (/api/health)
        id: backend
        run: |
          set -euo pipefail
          echo "## üß† Backend API" >> "$GITHUB_STEP_SUMMARY"

          url="https://vault-api.freijstack.com/api/health"
          echo "üîé Checking $url ..."

          code=$(
            curl -s -o /dev/null -w "%{http_code}" \
              --max-time 10 \
              --retry 2 --retry-delay 2 --retry-all-errors \
              "$url" || echo "000"
          )

          if [ "$code" = "200" ]; then
            echo "‚úÖ Backend API OK (HTTP $code)"
            echo "status=healthy" >> "$GITHUB_OUTPUT"
            echo "- ‚úÖ API healthy (HTTP $code)" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "‚ùå Backend API DOWN (HTTP $code)"
            echo "status=unhealthy" >> "$GITHUB_OUTPUT"
            echo "- ‚ùå API unhealthy (HTTP $code)" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      # ---------------------------
      # üîê SSH ‚Äî Database check
      # ---------------------------
      - name: üîê Setup SSH (for DB check)
        id: ssh
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          ssh-keyscan -H "${{ secrets.VPS_SSH_HOST }}" >> ~/.ssh/known_hosts

          ssh -i ~/.ssh/deploy_key \
            -o BatchMode=yes \
            -o ConnectTimeout=10 \
            -o ServerAliveInterval=5 \
            -o ServerAliveCountMax=2 \
            -o StrictHostKeyChecking=yes \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            "${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}" "echo '‚úÖ SSH OK'"

      - name: üóÑÔ∏è Check Database Connectivity (pg_isready)
        id: database
        run: |
          set -euo pipefail
          echo "## üóÑÔ∏è Database" >> "$GITHUB_STEP_SUMMARY"

          SSH="ssh -i ~/.ssh/deploy_key \
            -o BatchMode=yes \
            -o ConnectTimeout=10 \
            -o ServerAliveInterval=5 \
            -o ServerAliveCountMax=2 \
            -o StrictHostKeyChecking=yes \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"
          PROD_DIR="/srv/www/securevault/saas/securevault"

          echo "üóÑÔ∏è Checking PostgreSQL (pg_isready)..."

          $SSH "cd '$PROD_DIR' && docker compose ps" || true

          db_status=$(
            $SSH "cd '$PROD_DIR' && docker compose exec -T postgres pg_isready -U securevault" 2>&1 || echo "FAILED"
          )

          if echo "$db_status" | grep -q "accepting connections"; then
            echo "‚úÖ Database OK"
            echo "status=healthy" >> "$GITHUB_OUTPUT"
            echo "- ‚úÖ DB accepting connections" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "‚ùå Database DOWN"
            echo "üîé pg_isready output: $db_status"
            echo "status=unhealthy" >> "$GITHUB_OUTPUT"
            echo "- ‚ùå DB not ready" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: üßπ Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key || true

  auto-heal:
    name: üîß Auto-Heal Production
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: health-check

    if: >
      always() &&
      needs.health-check.result == 'failure' &&
      (
        github.event_name == 'schedule' ||
        (github.event_name == 'workflow_dispatch' && inputs.auto_heal == true)
      )

    steps:
      - name: üîê Setup SSH
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "${{ secrets.VPS_SSH_HOST }}" >> ~/.ssh/known_hosts

      - name: ‚è±Ô∏è Auto-Heal cooldown check (anti restart-loop)
        id: cooldown
        run: |
          set -euo pipefail

          SSH="ssh -i ~/.ssh/deploy_key -o BatchMode=yes -o ConnectTimeout=10 ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"
          PROD_DIR="/srv/www/securevault/saas/securevault"
          COOLDOWN_SECONDS=1800  # 30 minutes
          STAMP_FILE="/tmp/securevault_last_heal"

          echo "‚è±Ô∏è Checking cooldown..."

          now=$($SSH "date +%s")
          last=$($SSH "test -f '$STAMP_FILE' && cat '$STAMP_FILE' || echo 0")
          diff=$((now - last))

          if [ "$diff" -lt "$COOLDOWN_SECONDS" ]; then
            echo "üõë Cooldown active: last heal was $diff seconds ago (< $COOLDOWN_SECONDS)."
            echo "can_heal=false" >> "$GITHUB_OUTPUT"
            exit 0
          else
            echo "‚úÖ Cooldown passed. Auto-heal allowed."
            echo "can_heal=true" >> "$GITHUB_OUTPUT"
          fi

      - name: üîß Restart Production Services
        if: ${{ steps.cooldown.outputs.can_heal == 'true' }}
        run: |
          set -euo pipefail

          SSH="ssh -i ~/.ssh/deploy_key -o BatchMode=yes -o ConnectTimeout=10 ${{ secrets.VPS_SSH_USER }}@${{ secrets.VPS_SSH_HOST }}"

          $SSH << 'HEAL_SCRIPT'
            set -euo pipefail

            PROD_DIR="/srv/www/securevault/saas/securevault"
            STAMP_FILE="/tmp/securevault_last_heal"

            cd "$PROD_DIR"

            echo "üìä Current container status:"
            docker compose ps || true
            echo ""

            echo "üîÑ Restarting all production services..."
            docker compose restart

            echo "‚è≥ Waiting for services to stabilize..."
            sleep 25

            echo "üìä New container status:"
            docker compose ps || true
            echo ""

            echo "üîé Checking backend health (internal)..."
            backend_health=$(docker compose exec -T backend curl -s http://localhost:3001/api/health || echo "FAILED")

            if echo "$backend_health" | grep -qi "ok"; then
              echo "‚úÖ Auto-heal successful!"
              date +%s > "$STAMP_FILE"
            else
              echo "‚ö†Ô∏è Restart done but health still failing"
              echo "backend_health=$backend_health"
              exit 1
            fi
          HEAL_SCRIPT

      - name: üßπ Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key || true

  notify:
    name: üì¢ Health Status Notification
    runs-on: ubuntu-latest
    needs: [health-check, auto-heal]
    if: always()
    timeout-minutes: 3

    steps:
      - name: üì¢ Production Health Summary
        if: always()
        run: |
          set -euo pipefail

          echo "## üì¢ Production Health Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- üè• Health Check: **${{ needs.health-check.result }}**" >> "$GITHUB_STEP_SUMMARY"
          echo "- üîß Auto-Heal: **${{ needs.auto-heal.result }}**" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [ "${{ needs.health-check.result }}" = "success" ]; then
            echo "‚úÖ Production is **HEALTHY**" >> "$GITHUB_STEP_SUMMARY"
            echo "- üéØ https://vault.freijstack.com/login" >> "$GITHUB_STEP_SUMMARY"
            echo "- üéØ https://vault-api.freijstack.com/api/health" >> "$GITHUB_STEP_SUMMARY"
          elif [ "${{ needs.auto-heal.result }}" = "success" ]; then
            echo "‚ö†Ô∏è Production had issues but **auto-heal succeeded**" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "üö® **CRITICAL**: Health check failed and auto-heal did not recover" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: üì£ Console output
        run: |
          echo "üè• Health Check: ${{ needs.health-check.result }}"
          echo "üîß Auto-Heal: ${{ needs.auto-heal.result }}"

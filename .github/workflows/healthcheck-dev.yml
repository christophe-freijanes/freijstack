name: ğŸ§ª Health Check â€¢ Development

on:
  workflow_dispatch:
    inputs:
      auto_heal:
        description: "ğŸ”§ (DEV) RedÃ©marrer automatiquement si problÃ¨me dÃ©tectÃ©"
        required: false
        default: false
        type: boolean

  # DEV: monitoring lÃ©ger
  schedule:
    - cron: "0 * * * *" # toutes les heures

concurrency:
  group: development-health-check
  cancel-in-progress: true

permissions:
  contents: read
  actions: read

jobs:
  health-check:
    name: ğŸ§ª Check Development Health
    runs-on: ubuntu-latest
    timeout-minutes: 6

    outputs:
      backend_status: ${{ steps.backend.outputs.status }}
      leaks_count: ${{ steps.gitleaks.outputs.leaks_count }}

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------------------------
      # ğŸ” SECURITY â€” Secret Scan (DEV = non-blocking)
      # ---------------------------
      - name: ğŸ” Secret scanning (Gitleaks CLI)
        id: gitleaks
        run: |
          set -euo pipefail

          echo "â¬‡ï¸ Installing gitleaks (pinned version)..."
          GITLEAKS_VERSION="8.21.2"
          curl -sSL "https://github.com/gitleaks/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz" \
            | tar -xz gitleaks
          sudo mv gitleaks /usr/local/bin/gitleaks

          echo "ğŸ” Running gitleaks (redacted)..."
          # On ne stoppe pas tout de suite pour pouvoir produire le report
          gitleaks detect \
            --source . \
            --config .gitleaks.toml \
            --redact \
            --report-format json \
            --report-path gitleaks-report.json \
            --verbose || true

          # Garantit un JSON valide mÃªme si gitleaks n'a rien Ã©crit
          test -f gitleaks-report.json || echo "[]" > gitleaks-report.json

          leaks_count="$(jq 'length' gitleaks-report.json)"
          echo "leaks_count=${leaks_count}" >> "$GITHUB_OUTPUT"
          echo "ğŸ”¢ leaks_count=${leaks_count}"

          {
            echo ""
            echo "## ğŸ” Gitleaks (secrets scan)"
            echo ""
            echo "- **Total findings:** $leaks_count"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "$leaks_count" != "0" ]; then
            {
              echo ""
              echo "### ğŸ” Top 20 findings (metadata only)"
              jq -r '.[] | "- rule=\(.RuleID) file=\(.File):\(.StartLine) commit=\(.Commit|tostring|.[0:8])"' gitleaks-report.json \
                | head -n 20
              echo ""
              echo "> â„¹ï¸ Values are redacted. See artifact for full metadata."
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "- âœ… No findings detected." >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: ğŸ“ Upload gitleaks report (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report-dev
          path: gitleaks-report.json
          retention-days: 7
          if-no-files-found: error

      - name: ğŸ§° Prepare tools
        run: |
          set -euo pipefail
          echo "ğŸ§° Tools versions"
          curl --version | head -n 1

      # ---------------------------
      # ğŸŒ AVAILABILITY â€” Frontend URLs with retries + sleep (anti false-positives)
      # ---------------------------
      - name: ğŸŒ Public URLs Health Check (strong anti false-positives)
        run: |
          set -euo pipefail

          {
            echo "## ğŸŒ Public URLs Health Check"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

          # Warm-up: laisse le temps aux DNS/CDN/TLS de se stabiliser
          echo "â³ Warm-up 15s..."
          sleep 15

          # Format: "url|allowed_codes|label"
          URLS=(
            "https://portfolio.freijstack.com/|200,301,302|Portfolio"
            "https://christophe-freijanes.github.io/freijstack/|200,301,302|GitHub Pages"
            "https://vault.freijstack.com/login|200,301,302,404|SecureVault Frontend (shared)"
            "https://registry.freijstack.com/v2/|401,200|Docker Registry API (production)"
            "https://registry-ui.freijstack.com/|200,301,302|Docker Registry UI (production)"
          )

          # Fast pass + Grace pass
          FAST_RETRY=3
          FAST_DELAY=3
          GRACE_RETRY=8
          GRACE_DELAY=8

          # ParamÃ¨tres curl communs (anti faux positifs)
          # -4 : Ã©vite les soucis IPv6 (souvent la cause du HTTP 000)
          # --retry-all-errors + --retry-max-time : meilleure rÃ©silience
          CURL_COMMON=(
            -4
            -sS
            -L
            -o /dev/null
            -w "%{http_code}"
            --connect-timeout 12
            --max-time 35
            --retry 3
            --retry-delay 2
            --retry-all-errors
            --retry-max-time 120
            --user-agent "freijstack-healthcheck/1.1"
          )

          check_url() {
            local url="$1"
            local allowed="$2"
            local label="$3"
            local attempts="$4"
            local delay="$5"

            echo ""
            echo "ğŸ” Checking $label â†’ $url"
            echo "- **$label** ($url)" >> "$GITHUB_STEP_SUMMARY"

            # DNS debug
            host="$(echo "$url" | sed -E 's#https?://([^/]+).*#\1#')"
            if command -v dig >/dev/null 2>&1; then
              ips="$(dig +short "$host" | tr '\n' ' ' || true)"
              [ -n "${ips:-}" ] && echo "  ğŸŒ DNS: $ips" || echo "  ğŸŒ DNS: (no A/AAAA from runner)"
            fi

            for i in $(seq 1 "$attempts"); do
              echo "  â³ Attempt $i/$attempts..."

              # HEAD d'abord, fallback GET si HEAD pas supportÃ© / renvoie 405/000
              code="$(curl -I "${CURL_COMMON[@]}" "$url" 2>/tmp/curl_err || echo "000")"

              if [ "$code" = "405" ] || [ "$code" = "000" ]; then
                code="$(curl "${CURL_COMMON[@]}" "$url" 2>/tmp/curl_err || echo "000")"
              fi

              if echo ",$allowed," | grep -q ",$code,"; then
                echo "  âœ… OK (HTTP $code)"
                echo "  - âœ… HTTP $code (attempt $i/$attempts)" >> "$GITHUB_STEP_SUMMARY"
                return 0
              fi

              err="$(tail -n 1 /tmp/curl_err 2>/dev/null || true)"
              echo "  âš ï¸  HTTP $code (attempt $i/$attempts) $err"

              # Si HTTP 000, on attend un peu plus (souvent DNS/TLS)
              if [ "$code" = "000" ]; then
                sleep $((delay + 3))
              elif [ "$i" -lt "$attempts" ]; then
                sleep "$delay"
              fi
            done

            echo "  âŒ FAILED after $attempts attempts"
            echo "  - âŒ Failed after $attempts attempts (last HTTP $code)" >> "$GITHUB_STEP_SUMMARY"
            return 1
          }

          failures=0

          echo "### âš¡ Fast pass" >> "$GITHUB_STEP_SUMMARY"
          for entry in "${URLS[@]}"; do
            url="${entry%%|*}"
            rest="${entry#*|}"
            allowed="${rest%%|*}"
            label="${rest##*|}"

            if ! check_url "$url" "$allowed" "$label" "$FAST_RETRY" "$FAST_DELAY"; then
              failures=$((failures + 1))
            fi
          done

          if [ "$failures" -gt 0 ]; then
            {
              echo ""
              echo "### ğŸ§¯ Grace pass (final attempt)"
              echo "- Retrying with stronger tolerance..."
            } >> "$GITHUB_STEP_SUMMARY"

            failures=0
            for entry in "${URLS[@]}"; do
              url="${entry%%|*}"
              rest="${entry#*|}"
              allowed="${rest%%|*}"
              label="${rest##*|}"

              if ! check_url "$url" "$allowed" "$label" "$GRACE_RETRY" "$GRACE_DELAY"; then
                failures=$((failures + 1))
              fi
            done
          fi

          if [ "$failures" -gt 0 ]; then
            {
              echo ""
              echo "ğŸš¨ **Health check FAILED** (after grace pass)"
            } >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

          {
            echo ""
            echo "âœ… **All URLs healthy**"
          } >> "$GITHUB_STEP_SUMMARY"


      # ---------------------------
      # ğŸ§  API â€” Backend Health
      # ---------------------------
      - name: ğŸ” Check Backend SecureVault API (/api/health)
        id: backend
        run: |
          set -euo pipefail
          echo "## ğŸ§  Backend API" >> "$GITHUB_STEP_SUMMARY"

          url="https://vault-api.freijstack.com/api/health"
          echo "ğŸ” Checking $url ..."

          code=$(
            curl -s -o /dev/null -w "%{http_code}" \
              --max-time 10 \
              --retry 2 --retry-delay 2 --retry-all-errors \
              "$url" || echo "000"
          )

          if [ "$code" = "200" ]; then
            echo "âœ… Backend API OK (HTTP $code)"
            echo "status=healthy" >> "$GITHUB_OUTPUT"
            echo "- âœ… API healthy (HTTP $code)" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "âŒ Backend API DOWN (HTTP $code)"
            echo "status=unhealthy" >> "$GITHUB_OUTPUT"
            echo "- âŒ API unhealthy (HTTP $code)" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: ğŸ§¹ Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key || true

  auto-heal:
    name: ğŸ”§ Auto-Heal Development
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: health-check

    # âœ… DEV: auto-heal UNIQUEMENT manuel (sinon Ã§a masque les rÃ©gressions)
    if: >
      always() &&
      needs.health-check.result == 'failure' &&
      github.event_name == 'workflow_dispatch' &&
      inputs.auto_heal == true

    steps:
      - name: ğŸ” Setup SSH
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "${{ secrets.VPS_SSH_HOST }}" >> ~/.ssh/known_hosts

      - name: ğŸ”§ Restart services (DEV/shared) â€” example
        run: |
          echo "ğŸ§¯ Manual auto-heal triggered (DEV/shared)."
          echo "â¡ï¸ Ici tu mets tes commandes SSH si tu as un environnement DEV."

      - name: ğŸ§¹ Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key || true

  notify:
    name: ğŸ“¢ Health Status Notification
    runs-on: ubuntu-latest
    needs: [health-check, auto-heal]
    if: always()
    timeout-minutes: 3

    steps:
      - name: ğŸ“¢ Development Health Summary
        if: always()
        run: |
          set -euo pipefail

          {
            echo "## ğŸ“¢ Development Health Summary"
            echo ""
            echo "- ğŸ¥ Health Check: **${{ needs.health-check.result }}**"
            echo "- ğŸ”§ Auto-Heal: **${{ needs.auto-heal.result }}**"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "${{ needs.health-check.result }}" = "success" ]; then
            {
              echo "âœ… Development is **HEALTHY**"
              echo "- ğŸ¯ https://vault.freijstack.com/login"
              echo "- ğŸ¯ https://vault-api.freijstack.com/api/health"
            } >> "$GITHUB_STEP_SUMMARY"
          elif [ "${{ needs.auto-heal.result }}" = "success" ]; then
            echo "âš ï¸ Development had issues but **auto-heal succeeded**" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "ğŸš¨ **CRITICAL**: Health check failed and auto-heal did not recover" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: ğŸ“£ Console output
        run: |
          echo "ğŸ¥ Health Check: ${{ needs.health-check.result }}"
          echo "ğŸ”§ Auto-Heal: ${{ needs.auto-heal.result }}"
